<!DOCTYPE html><html lang="en"><head>
        <title>
            AZ-220ZH-Microsoft-Azure-IoT-Developer
        </title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" crossorigin="anonymous">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" crossorigin="anonymous">
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/vs.min.css">
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        <link rel="stylesheet" href="../../assets/css/style_v%3D653337691cd169b6aa5719d4ea66f4e6a878a19c.css">
    </head>
    <body data-spy="scroll" data-target="#linksMenu">
    <nav class="navbar navbar-expand-lg navbar-dark bg-black">
        <div class="container d-flex justify-content-between">
            <a class="my-1 title text-azure text-uppercase" href="../../">
                AZ-220ZH-Microsoft-Azure-IoT-Developer
            </a>
            <a href="https://github.com/MicrosoftLearning/AZ-220ZH-Microsoft-Azure-IoT-Developer" target="_blank" class="btn btn-sm btn-outline-secondary text-light">
                <i class="fa fa-github" aria-hidden="true"></i>
                <span class="ml-2">GitHub</span>
            </a>
        </div>
    </nav>
    <div class="container">
        <main class="row extra-padding">
            <aside class="col-sm-2">       
                <nav id="linksMenu" class="toc sticky-top">
                    <ul class="nav navbar-nav flex-column">
                    <li class="nav-item"><a class="nav-link" href="#练习-1验证实验室先决条件">练习 1：验证实验室先决条件</a></li><li class="nav-item"><a class="nav-link" href="#练习-2使用-openssl-生成和配置-x509-ca-证书">练习 2：使用 OpenSSL 生成和配置 X.509 CA 证书</a></li><li class="nav-item"><a class="nav-link" href="#练习-3使用-x509-证书配置模拟设备">练习 3：使用 X.509 证书配置模拟设备</a></li><li class="nav-item"><a class="nav-link" href="#练习-4创建更多模拟设备实例">练习 4：创建更多模拟设备实例</a></li><li class="nav-item"><a class="nav-link" href="#练习-5测试模拟设备">练习 5：测试模拟设备</a></li><li class="nav-item"><a class="nav-link" href="#练习-5从注册组取消预配单个设备">练习 5：从“注册组”取消预配单个设备</a></li><li class="nav-item"><a class="nav-link" href="#练习-6取消预配组注册">练习 6：取消预配组注册</a></li></ul>
                </nav>         
            </aside>
            <hr class>
            <article class="col-sm-10 mb-5">
                <h1 id="使用-dps-安全且大规模地自动预配-iot-设备">使用 DPS 安全且大规模地自动预配 IoT 设备</h1>

<h2 id="实验室场景">实验室场景</h2>

<p>你目前针对 Contoso 的资产监视和跟踪解决方案所做的工作使你能够使用“单独注册”方法验证设备预配和取消预配流程。管理团队现在要求你开始测试相关流程以便在更大规模上实施。</p>

<p>要使项目继续进行，你需要证明设备预配服务可用于使用 X.509 证书身份验证自动安全地注册更多设备。将设置组注册，验证是否满足 Contoso 的要求。</p>

<p>将创建以下资源：</p>

<p><a href="media/LAB_AK_06-architecture.png" target="_blank"><img src="media/LAB_AK_06-architecture.png" alt="实验室 6 基础结构"></a></p>

<h2 id="本实验室概览">本实验室概览</h2>

<p>在本实验室中，你首先将查看实验室先决条件，并根据需要运行脚本来确保你的 Azure 订阅包含所需的资源。然后，在 Azure Cloud Shell 中使用 OpenSSL 生成 X.509 根 CA 证书，并使用该根证书在设备预配服务 (DPS) 中配置组注册。之后，使用根证书生成设备证书，后面需要在模拟设备代码中使用该证书将设备预配到 IoT 中心。在设备代码中，需要实现对用于执行设备初始配置的设备孪生属性的访问。然后测试模拟设备。结束本实验室所有操作时，需要取消预配整个组注册。本实验室包括以下练习：</p>

<ul>
  <li>验证实验室先决条件</li>
  <li>使用 OpenSSL 生成和配置 X.509 CA 证书</li>
  <li>使用 X.509 证书配置模拟设备</li>
  <li>测试模拟设备</li>
  <li>取消预配组注册</li>
</ul>

<h2 id="实验室说明">实验室说明</h2>

<h3 id="练习-1验证实验室先决条件">练习 1：验证实验室先决条件</h3>

<p>本实验室假定以下 Azure 资源可用：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">资源类型</th>
      <th style="text-align: left">资源名称</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">资源组</td>
      <td style="text-align: left">rg-az220</td>
    </tr>
    <tr>
      <td style="text-align: left">IoT 中心</td>
      <td style="text-align: left">iot-az220-training-{your-id}</td>
    </tr>
    <tr>
      <td style="text-align: left">设备预配服务</td>
      <td style="text-align: left">dps-az220-training-{your-id}</td>
    </tr>
  </tbody>
</table>

<p>如果这些资源不可用，请按照以下说明运行 <strong>“lab06-setup.azcli”</strong> 脚本，然后再前往练习 2。脚本文件包含在本地克隆作为开发环境配置（实验室 3）的 GitHub 存储库中。</p>

<p>写入 <strong>lab06-setup.azcli</strong> 脚本，并在 <strong>Bash</strong> shell 环境中运行，执行此操作最简便的方法是在 Azure Cloud Shell 中。</p>

<ol>
  <li>
    <p>使用浏览器，打开 <a href="https://shell.azure.com/">Azure Cloud Shell</a>，并使用本课程使用的 Azure 订阅登录。</p>

    <p>如果系统提示设置 Cloud Shell 的存储，请接受默认设置。</p>
  </li>
  <li>
    <p>验证 Cloud Shell 是否在使用 <strong>Bash</strong>。</p>

    <p>Azure Cloud Shell 页面左上角的下拉菜单用于选择环境。验证所选的下拉值是否为 <strong>Bash</strong>。</p>
  </li>
  <li>
    <p>在 Cloud Shell 工具栏上，单击 <strong>“上传/下载文件”</strong> （从右数第四个按钮）。</p>
  </li>
  <li>
    <p>在下拉菜单中，单击 <strong>“上传”</strong>。</p>
  </li>
  <li>
    <p>在“文件选择”对话框中，导航到配置开发环境时下载的 GitHub 实验室文件的文件夹位置。</p>

    <p>在“实验室 3：<em>设置开发环境</em>，你可以通过下载 ZIP 文件并从本地提取内容来克隆包含实验室资源的 GitHub 存储库。提取的文件夹结构包括以下文件夹路径：</p>

    <ul>
      <li>Allfiles
        <ul>
          <li>实验室
            <ul>
              <li>06 - 在 DPS 中自动注册设备
                <ul>
                  <li>设置</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>

    <p>lab06-setup.azcli 脚本文件位于实验室 6 的 Setup 文件夹中。</p>
  </li>
  <li>
    <p>选择 <strong>“lab06-setup.azcli”</strong> 文件，然后单击 <strong>“打开”</strong>。</p>

    <p>文件上传完成后，系统将显示一条通知。</p>
  </li>
  <li>
    <p>若要验证在 Azure Cloud Shell 中已上传了正确文件，请输入以下命令：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">code</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock0" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock0" class="mt-0"><code class="language-bash hljs"> ls
</code></pre>

    <p>使用 <code>ls</code> 命令列出当前目录的内容。你应该会看到列出的 lab06-setup.azcli 文件。</p>
  </li>
  <li>
    <p>若要为此实验室创建一个包含安装脚本的目录，然后移至该目录，请输入以下 Bash 命令：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">code</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock1" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock1" class="mt-0"><code class="language-bash hljs"> mkdir lab6
 mv lab06-setup.azcli lab6
 <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> lab6
</code></pre>
  </li>
  <li>
    <p>为了确保 <strong>lab06-setup.azcli</strong> 脚本具有执行权限，请输入以下命令：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">code</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock2" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock2" class="mt-0"><code class="language-bash hljs"> chmod +x lab06-setup.azcli
</code></pre>
  </li>
  <li>
    <p>在“Cloud Shell”工具栏上，请单击 <strong>“打开编辑器”</strong> （右侧的第二个按钮 - <strong>{ }</strong>）以启用对 lab06-setup.azcli 文件的访问。</p>
  </li>
  <li>
    <p>在 <strong>“文件”</strong> 列表中，要展开 lab6 文件夹并打开脚本文件，请先单击 <strong>“lab6”</strong>，再单击 <strong>“lab06-setup.azcli”</strong>。</p>

    <p>编辑器现在将显示 <strong>“lab06-setup.azcli”</strong> 文件的内容。</p>
  </li>
  <li>
    <p>在编辑器中，更新 <code>{your-id}</code> 和 <code>{your-location}</code> 变量的值。</p>

    <p>以下面的示例为例，需要将 <code>{your-id}</code> 设置为在本课程开始时创建的唯一 ID（即 <strong>cah191211</strong>），然后将 <code>{your-location}</code> 设置为对你的资源有意义的位置。</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">code</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock3" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock3" class="mt-0"><code class="language-bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#!/bin/bash</span></span>

 <span class="hljs-comment"><span class="hljs-comment"># 更改这些值！</span></span>
 YourID=<span class="hljs-string"><span class="hljs-string">"{your-id}"</span></span>
 Location=<span class="hljs-string"><span class="hljs-string">"{your-location}"</span></span>
</code></pre>

    <blockquote>
      <p><strong>备注：</strong>  应将 <code>{your-location}</code> 变量设置为要部署所有资源的区域的短名称。输入以下命令，可以看到可用位置及其短名称的列表（<strong>“名称”</strong> 列）：</p>
    </blockquote>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">code</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock4" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock4" class="mt-0"><code class="language-bash hljs"> az account list-locations -o Table

 DisplayName           Latitude    Longitude    Name
 --------------------  ----------  -----------  ------------------
 East Asia             22.267      114.188      eastasia
 Southeast Asia        1.283       103.833      southeastasia
 Central US            41.5908     -93.6208     centralus
 East US               37.3719     -79.8164     eastus
 East US 2             36.6681     -78.3889     eastus2
</code></pre>
  </li>
  <li>
    <p>要保存对文件所做的更改并关闭编辑器，请单击编辑器窗口右上角的 “<strong>…</strong>”，然后单击 <strong>“关闭编辑器”</strong>。</p>

    <p>如果提示保存，请单击 <strong>“保存”</strong>，编辑器将会关闭。</p>

    <blockquote>
      <p><strong>备注：</strong>  可以使用 <strong>Ctrl+S</strong> 随时保存，使用 <strong>Ctrl+Q</strong> 关闭编辑器。</p>
    </blockquote>
  </li>
  <li>
    <p>要创建本实验室所需的资源，请输入以下命令：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">code</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock5" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock5" class="mt-0"><code class="language-bash hljs"> ./lab06-setup.azcli
</code></pre>

    <p>运行将花费几分钟时间。每个步骤完成时，你都会看到输出。</p>

    <p>脚本完成后，就可以继续实验室的内容。</p>
  </li>
</ol>

<h3 id="练习-2使用-openssl-生成和配置-x509-ca-证书">练习 2：使用 OpenSSL 生成和配置 X.509 CA 证书</h3>

<p>在本练习中，你将在 Azure Cloud Shell 中使用 OpenSSL 生成 X.509 CA 证书。此证书将用于在设备预配服务 (DPS) 中配置组注册。</p>

<h4 id="任务-1生成证书">任务 1：生成证书</h4>

<ol>
  <li>
    <p>如有必要，使用你在本课程中使用的 Azure 帐户凭据登录到 <a href="https://portal.azure.com">Azure 门户</a>。</p>

    <p>如果有多个 Azure 帐户，请确保使用与本课程要使用的订阅绑定的帐户登录。</p>
  </li>
  <li>
    <p>在门户窗口的右上角，请单击 <strong>“Cloud Shell”</strong> 打开 Azure Cloud Shell。</p>

    <p>Cloud Shell 按钮有一个代表命令提示符 <strong><code>&gt;_</code></strong> 的图标。</p>

    <p>Cloud Shell 窗口将在靠近显示屏底部的位置打开。</p>
  </li>
  <li>
    <p>在 Cloud Shell 窗口的左上角，确保将 <strong>Bash</strong> 选为环境选项。</p>

    <blockquote>
      <p><strong>备注：</strong>  Azure Cloud Shell 的 <em>Bash</em> 和 <em>PowerShell</em> 界面都支持使用 <strong>OpenSSL</strong>。在本练习中，你将使用专为 <em>Bash</em> shell 编写的一些帮助程序脚本。</p>
    </blockquote>
  </li>
  <li>
    <p>在 Cloud Shell 命令提示符下，要创建并移至新目录中，请输入以下命令：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">shell</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock6" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock6" class="mt-0"><code class="language-sh hljs bash"> <span class="hljs-comment"><span class="hljs-comment"># 确保当前目录是用户的主目录</span></span>
 <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ~

 <span class="hljs-comment"><span class="hljs-comment"># 创建一个名为“certificates”的目录</span></span>
 mkdir certificates

 <span class="hljs-comment"><span class="hljs-comment"># 将目录更改为“certificates”目录</span></span>
 <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> certificates
</code></pre>
  </li>
  <li>
    <p>若要下载和准备要使用的 Azure IoT 帮助程序脚本，请在 Cloud Shell 命令提示符下输入以下命令：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">shell</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock7" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock7" class="mt-0"><code class="language-sh hljs bash"> <span class="hljs-comment"><span class="hljs-comment"># 下载帮助程序脚本文件</span></span>
 curl https://raw.githubusercontent.com/Azure/azure-iot-sdk-c/master/tools/CACertificates/certGen.sh --output certGen.sh
 curl https://raw.githubusercontent.com/Azure/azure-iot-sdk-c/master/tools/CACertificates/openssl_device_intermediate_ca.cnf --output openssl_device_intermediate_ca.cnf
 curl https://raw.githubusercontent.com/Azure/azure-iot-sdk-c/master/tools/CACertificates/openssl_root_ca.cnf --output openssl_root_ca.cnf

 ＃更新脚本权限，以便用户可以读取、写入和执行它
 chmod 700 certGen.sh
</code></pre>

    <p>帮助程序脚本和支持文件是从托管在 Github 上的 <strong>“Azure/azure-iot-sdk-c”</strong> 开放源代码项目中下载的，该项目是 Azure IoT 设备 SDK 的一个组件。可以借助 <strong>certGen.sh</strong> 帮助程序脚本了解如何使用 CA 证书，而无需深入了解 OpenSSL 配置的细节（这超出了本课程的范围）。</p>

    <p>有关使用此帮助程序脚本的其他说明，以及有关如何使用 PowerShell 代替 Bash 的说明，请参见以下链接：<a href="https://github.com/Azure/azure-iot-sdk-c/blob/master/tools/CACertificates/CACertificateOverview.md">https://github.com/Azure/azure-iot-sdk-c/blob/master/tools/CACertificates/CACertificateOverview.md</a></p>

    <blockquote>
      <p><strong>警告</strong>： 由此帮助程序脚本创建的证书<strong>禁止</strong>用于生产。它们包含硬编码的密码（“<em>1234</em>”），将在 30 天后过期，并且最重要的是，它们只用于演示目的，旨在帮助你快速了解 CA 证书。基于 CA 证书构建产品时，应务必按照公司的最佳安全做法来创建证书和管理生命周期。</p>
    </blockquote>

    <p>如果感兴趣，你可以使用 Cloud Shell 内置的编辑器来快速扫描你下载的脚本文件的内容。</p>

    <ul>
      <li>在 Cloud Shell 中，要打开编辑器，请单击 <strong>“<code>{}</code>”</strong>。</li>
      <li>在“文件”列表中，单击 <strong>“证书”</strong>，然后单击 <strong>“certGen.sh”</strong></li>
    </ul>

    <blockquote>
      <p><strong>备注：</strong> 如果你熟悉 Bash 环境中的其他文本文件查看工具，例如 <code>more</code> 或 <code>vi</code> 命令，你也可以使用这些工具。</p>
    </blockquote>

    <p>下一步是使用该脚本来创建根证书和中间证书。</p>
  </li>
  <li>
    <p>要生成根证书和中间证书，请输入以下命令：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">shell</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock8" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock8" class="mt-0"><code class="language-sh hljs bash"> ./certGen.sh create_root_and_intermediate
</code></pre>

    <p>注意，你使用 <code>create_root_and_intermediate</code> 选项运行了该脚本。此命令假设你正在从 <code>~/certificates</code> 目录运行脚本。</p>

    <p>此命令生成了名为 <code>azure-iot-test-only.root.ca.cert.pem</code> 的根 CA 证书，并将该证书放在了 <code>./certs</code> 目录中，该目录位于你创建的证书目录下。</p>
  </li>
  <li>
    <p>要将根证书下载到本地计算机（以便上传到 DPS），请输入以下命令：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">shell</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock9" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock9" class="mt-0"><code class="language-sh hljs bash"> download ~/certificates/certs/azure-iot-test-only.root.ca.cert.pem
</code></pre>

    <p>系统将提示你将文件保存到本地计算机。记下文件的保存位置，在下一个任务中将需要用到它。</p>
  </li>
</ol>

<h4 id="任务-2配置-dps-以信任根证书">任务 2：配置 DPS 以信任根证书</h4>

<ol>
  <li>
    <p>在 Azure 门户中，打开“设备预配服务”。</p>

    <p>通过单击 <code>dps-az220-training-{your-id}</code> ，可从仪表板上的“资源”磁贴访问设备预配服务。</p>
  </li>
  <li>
    <p>在 <strong>“dps-az220-training-{your-id}”</strong> 边栏选项卡的左侧菜单上，在 <strong>“设置”</strong> 下，单击 <strong>“证书”</strong>。</p>
  </li>
  <li>
    <p>在 <strong>“证书”</strong> 窗格的顶部，单击 <strong>“+ 添加”</strong>。</p>

    <p>单击 <strong>“+ 添加”</strong> 会启动将 X.509 CA 证书上传到 DPS 服务的过程。</p>
  </li>
  <li>
    <p>在 <strong>“添加证书”</strong> 边栏选项卡的 <strong>“证书名称”</strong> 下，输入 <strong>root-ca-cert</strong>。</p>

    <p>重要的是要提供一个使你能够区分各个证书的名称，例如根证书、中间证书或链中同一层次结构级别的多个证书。</p>

    <blockquote>
      <p><strong>备注：</strong> 你输入的根证书名称可以与证书文件的名称相同，也可以不同。你提供的名称是逻辑名称，与内容 X.509 CA 证书中嵌入的公用名称__不相关。</p>
    </blockquote>
  </li>
  <li>
    <p>在 <strong>“证书 .pem 或 .cer 文件”</strong> 下，在文本框右侧，单击 <strong>“打开”</strong>。</p>

    <p>单击文本字段右侧的 <strong>“打开”</strong> 按钮后会打开一个“打开文件”对话框，在该对话框中，可以导航到先前下载的 <code>azure-iot-test-only.root.ca.cert.pem</code> CA 证书。</p>
  </li>
  <li>
    <p>导航到将根 CA 证书文件下载到的文件夹位置，单击 <strong>“azure-iot-test-only.root.ca.cert.pem”</strong>，然后单击 <strong>“打开”</strong>。</p>
  </li>
  <li>
    <p>在 <strong>“添加证书”</strong> 边栏选项卡底部，单击 <strong>“保存”</strong>。</p>

    <p>上传 X.509 CA 证书后，“证书”窗格将显示该证书，并且 <strong>“状态”</strong> 值为 <strong>“未验证”</strong>。在使用此 CA 证书对 DPS 的设备进行身份验证之前，你需要验证证书的“所有权证明”__ 。</p>
  </li>
  <li>
    <p>要开始验证证书的“所有权证明”，请单击 <strong>“root-ca-cert”</strong> 。</p>
  </li>
  <li>
    <p>在 <strong>“证书详细信息”</strong> 窗格底部，单击 <strong>“生成验证码”</strong>。</p>

    <p>你可能需要向下滚动才能看到 <strong>“生成验证码”</strong> 按钮。</p>

    <p>单击该按钮后，将在“验证码”字段（位于按钮上方）中生成代码。</p>
  </li>
  <li>
    <p>在 <strong>“验证码”</strong> 的右侧，单击 <strong>“复制到剪贴板”</strong>。</p>

    <p>通过上传使用刚刚在 DPS 中生成的验证码从 CA 证书生成的证书，向 DPS 提供 CA 证书的“拥有证明”。这是如何证明你实际拥有 CA 证书的方法。</p>

    <blockquote>
      <p><strong>重要说明</strong>： 生成验证证书时，需要保持打开 <strong>“证书详细信息”</strong> 窗格。如果关闭窗格，将导致验证码无效，并且需要生成一个新的验证码。</p>
    </blockquote>
  </li>
  <li>
    <p>如果仍然无法在之前的基础上打开，则打开 <strong>Azure Cloud Shell</strong>，并导航到 <code>~/certificates</code> 目录。</p>
  </li>
  <li>
    <p>要创建验证证书，请输入以下命令：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">shell</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock10" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock10" class="mt-0"><code class="language-sh hljs bash"> ./certGen.sh create_verification_certificate &lt;verification-code&gt;
</code></pre>

    <p>请务必将 <code>&lt;verification-code&gt;</code> 占位符替换为由 Azure 门户生成的<strong>验证码</strong>。</p>

    <p>例如，你运行的命令将如下所示：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">shell</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock11" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock11" class="mt-0"><code class="language-sh hljs bash"> ./certGen.sh create_verification_certificate 49C900C30C78D916C46AE9D9C124E9CFFD5FCE124696FAEA
</code></pre>

    <p>这会生成一个链接到 CA 证书的验证证书__。证书的主题是验证码。生成的名为 <code>verification-code.cert.pem</code> 的验证证书位于 Azure Cloud Shell 的 <code>./certs</code> 目录中。</p>

    <p>下一步是将验证证书下载到本地计算机（类似于之前对根证书执行的操作），以便稍后将其上传到 DPS。</p>
  </li>
  <li>
    <p>要将验证证书下载到本地计算机，请输入以下命令：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">shell</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock12" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock12" class="mt-0"><code class="language-sh hljs bash"> download ~/certificates/certs/verification-code.cert.pem
</code></pre>

    <blockquote>
      <p><strong>备注：</strong> 根据 Web 浏览器的不同，此时系统可能会显示一条提示，让你确定是否允许多次下载。如果系统对你的下载命令无响应，请确保屏幕上的其他地方没有显示要求你提供允许下载权限的提示。</p>
    </blockquote>
  </li>
  <li>
    <p>切换回 <strong>“证书详细信息”</strong> 窗格。</p>

    <p>DPS 服务的此窗格在 Azure 门户中应仍为打开状态。</p>
  </li>
  <li>
    <p>在 <strong>“证书详细信息”</strong> 窗格底部， <strong>“验证证书 .pem 或 .cer 文件”</strong> 右侧，单击 <strong>“打开”</strong>。</p>
  </li>
  <li>
    <p>在“打开文件”对话框中，导航到 downloads 文件夹，单击 <strong>“verification-code.cert.pem”</strong>，然后单击 <strong>“打开”</strong>。</p>
  </li>
  <li>
    <p>在底部的 <strong>“证书详细信息”</strong> 窗格中，单击 <strong>“验证”</strong>。</p>
  </li>
  <li>
    <p>在 <strong>“证书”</strong> 窗格中，确保证书的 <strong>“状态”</strong> 现在设置为 <strong>“已验证”</strong>。</p>

    <p>可能需要单击窗格顶部的 <strong>“刷新”</strong> 按钮 （位于 <strong>“添加”</strong> 按钮右侧）才能反映出此更改。</p>
  </li>
</ol>

<h4 id="任务-3在-dps-中创建组注册x509-证书">任务 3：在 DPS 中创建组注册（X.509 证书）</h4>

<p>在本练习中，你将在设备预配服务 (DPS) 中使用“X.509 证书证明”新建注册组。</p>

<ol>
  <li>
    <p>在 <strong>“dps-az220-training-{your-id}”</strong> 边栏选项卡的左侧菜单上，在 <strong>“设置”</strong> 下，单击 <strong>“管理注册”</strong>。</p>
  </li>
  <li>
    <p>在顶部 <strong>“管理注册”</strong> 窗格中，单击 <strong>“添加注册组”</strong>。</p>

    <p>回想一下，注册组基本上是可以通过自动预配进行注册的设备记录。</p>
  </li>
  <li>
    <p>在 <strong>“添加注册组”</strong> 边栏选项卡上的 <strong>“组名”</strong> 下，输入 <strong>“eg-test-simulated-devices”</strong></p>
  </li>
  <li>
    <p>确保将 <strong>“认证类型”</strong> 设置为 <strong>“证书”</strong>。</p>
  </li>
  <li>
    <p>确保将 <strong>“证书类型”</strong> 字段设置为 <strong>“CA 证书”</strong>。</p>
  </li>
  <li>
    <p>在 <strong>“初级证书”</strong> 下拉菜单中，选择之前上传到 DPS 的 CA 证书，如 <strong>root-ca-cert</strong>。</p>
  </li>
  <li>
    <p>将 <strong>“二级证书”</strong> 下拉菜单保留设置为 <strong>“未选择证书”</strong>。</p>

    <p>二级证书通常用于证书轮换，以容纳到期的证书或已泄露的证书。你可以在此处找到有关证书轮换的更多信息：<a href="https://docs.microsoft.com/zh-cn/azure/iot-dps/how-to-roll-certificates">https://docs.microsoft.com/zh-cn/azure/iot-dps/how-to-roll-certificates</a></p>
  </li>
  <li>
    <p>将 <strong>“选择要将设备分配给中心的方式”</strong> 字段继续设置为 <strong>“均衡加权分布”</strong>。</p>

    <p>在具有多个分布式中心的大型环境中，此设置将控制如何选择应接收此设备注册的 IoT 中心。你将具备一个与本实验室中的注册相关的  IoT 中心，因此如何将设备分配给 IoT 中心在本实验室方案中并不真正适用。</p>
  </li>
  <li>
    <p>注意， <strong>“选择可以分配给该组的 IoT 中心”</strong> 下拉菜单中勾选了 <strong>“iot-az220-training-{your-id}”</strong> IoT 中心。</p>

    <p>此字段用于确保在预配设备时将其添加到正确的 IoT 中心。</p>
  </li>
  <li>
    <p>将 <strong>“选择重新预配设备请求时如何处理设备数据”</strong> 字段保留为 <strong>“重新预配并迁移数据”</strong>。</p>

    <p>通过此字段，可以对重新预配行为进行高级控制。所谓重新预配，是指同一设备（由同一注册 ID 指示）在成功预配至少一次之后再次提交配置请求的行为。</p>
  </li>
  <li>
    <p>在 <strong>“初始设备孪生状态”</strong> 字段中，按如下所示修改 JSON 对象：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">code</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock13" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock13" class="mt-0"><code class="language-json hljs"> {
     <span class="hljs-attr"><span class="hljs-attr">"tags"</span></span>: {},
     <span class="hljs-attr"><span class="hljs-attr">"properties"</span></span>: {
         <span class="hljs-attr"><span class="hljs-attr">"desired"</span></span>: {
             <span class="hljs-attr"><span class="hljs-attr">"telemetryDelay"</span></span>: <span class="hljs-string"><span class="hljs-string">"1"</span></span>
         }
     }
 }
</code></pre>

    <p>此 JSON 数据表示此注册组中所包含任何设备的设备孪生必需属性的初始配置。</p>

    <p>设备将使用 <code>properties.desired.telemetryDelay</code> 属性来设置读取遥测数据并将其发送到 IoT 中心的时间延迟。</p>
  </li>
  <li>
    <p>将 <strong>“启用输入”</strong> 保留设置为 <strong>“启用”</strong>。</p>

    <p>通常需要启用新的注册项并保持启用状态。</p>
  </li>
  <li>
    <p>在 <strong>“添加注册组”</strong> 边栏选项卡顶部，单击 <strong>“保存”</strong>。</p>
  </li>
</ol>

<h3 id="练习-3使用-x509-证书配置模拟设备">练习 3：使用 X.509 证书配置模拟设备</h3>

<p>在本练习中，将使用根证书生成一个设备证书，并配置一个模拟设备，该设备通过使用设备证书进行认证来实现连接。</p>

<h4 id="任务-1生成设备证书">任务 1：生成设备证书</h4>

<ol>
  <li>
    <p>如有必要，请使用 Azure 帐户凭据登录到 Azure 门户。</p>

    <p>如果有多个 Azure 帐户，请确保使用与本课程要使用的订阅绑定的帐户登录。</p>
  </li>
  <li>
    <p>在 Azure 门户工具栏上，单击 <strong>“Cloud Shell”</strong></p>

    <p>Azure 门户工具栏贯穿门户窗口的顶部。Cloud Shell 按钮是自右往左的第 6 项。</p>
  </li>
  <li>
    <p>验证 Cloud Shell 是否在使用 <strong>Bash</strong>。</p>

    <p>Azure Cloud Shell 页面左上角的下拉菜单用于选择环境。验证所选的下拉值是否为 <strong>Bash</strong>。</p>
  </li>
  <li>
    <p>在 Cloud Shell 命令提示符处，输入以下命令可导航到 <code>~/certificates</code> 目录：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">shell</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock14" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock14" class="mt-0"><code class="language-sh hljs bash"> <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ~/certificates
</code></pre>

    <p><code>~/certificates</code> 目录是 <code>certGen.sh</code> 帮助程序脚本的下载目录。之前在此选项卡中使用这些脚本生成了 DPS 的 CA 证书。此帮助程序脚本还将用于在 CA 证书链中生成设备证书。</p>
  </li>
  <li>
    <p>要在 CA 证书链中生成 X.509 设备证书，请输入以下命令：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">shell</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock15" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock15" class="mt-0"><code class="language-sh hljs bash"> ./certGen.sh create_device_certificate sensor-thl-2000
</code></pre>

    <p>此命令将创建一个新的 X.509 证书，该证书由先前生成的 CA 证书签名。注意，设备 ID（<code>sensor-thl-2000</code>）已传递到 <code>certGen.sh</code> 脚本的<code>create_device_certificate</code> 命令。该设备 ID 将在设备证书的公用名称__（即 <code>CN=</code>）值中设置。此证书将为你的模拟设备生成一个叶设备 X.509 证书，并且设备将使用此证书向设备预配服务 (DPS) 进行身份验证。</p>

    <p>完成 <code>create_device_certificate</code> 命令后，生成的 X.509 设备证书将命名为 <code>new-device.cert.pfx</code>，并将存放在 <code>/certs</code> 子目录中。</p>

    <blockquote>
      <p><strong>备注：</strong> 此命令将覆盖 <code>/certs</code> 子目录中的所有现有设备证书。如果要为多个设备创建证书，请确保每次运行命令时都保存 <code>new-device.cert.pfx</code> 的副本。</p>
    </blockquote>
  </li>
  <li>
    <p>要重命名刚创建的设备证书，请输入以下命令：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">shell</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock16" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock16" class="mt-0"><code class="language-sh hljs bash"> mv ~/certificates/certs/new-device.cert.pfx ~/certificates/certs/sensor-thl-2000-device.cert.pfx
 mv ~/certificates/certs/new-device.cert.pem ~/certificates/certs/sensor-thl-2000-device.cert.pem
</code></pre>
  </li>
  <li>
    <p>若要再创建四个设备证书，请输入以下命令：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">shell</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock17" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock17" class="mt-0"><code class="language-sh hljs bash"> ./certGen.sh create_device_certificate sensor-thl-2001
 mv ~/certificates/certs/new-device.cert.pfx ~/certificates/certs/sensor-thl-2001-device.cert.pfx
 mv ~/certificates/certs/new-device.cert.pem ~/certificates/certs/sensor-thl-2001-device.cert.pem

 ./certGen.sh create_device_certificate sensor-thl-2002
 mv ~/certificates/certs/new-device.cert.pfx ~/certificates/certs/sensor-thl-2002-device.cert.pfx
 mv ~/certificates/certs/new-device.cert.pem ~/certificates/certs/sensor-thl-2002-device.cert.pem

 ./certGen.sh create_device_certificate sensor-thl-2003
 mv ~/certificates/certs/new-device.cert.pfx ~/certificates/certs/sensor-thl-2003-device.cert.pfx
 mv ~/certificates/certs/new-device.cert.pem ~/certificates/certs/sensor-thl-2003-device.cert.pem

 ./certGen.sh create_device_certificate sensor-thl-2004
 mv ~/certificates/certs/new-device.cert.pfx ~/certificates/certs/sensor-thl-2004-device.cert.pfx
 mv ~/certificates/certs/new-device.cert.pem ~/certificates/certs/sensor-thl-2004-device.cert.pem
</code></pre>
  </li>
  <li>
    <p>要将生成的 X.509 设备证书从 Cloud Shell 下载到本地计算机，请输入以下命令：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">shell</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock18" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock18" class="mt-0"><code class="language-sh hljs bash"> download ~/certificates/certs/sensor-thl-2000-device.cert.pfx
 download ~/certificates/certs/sensor-thl-2001-device.cert.pfx
 download ~/certificates/certs/sensor-thl-2002-device.cert.pfx
 download ~/certificates/certs/sensor-thl-2003-device.cert.pfx
 download ~/certificates/certs/sensor-thl-2004-device.cert.pfx
</code></pre>

    <p>在下一个任务中，将开始构建模拟设备，这些设备将使用 X.509 设备证书向设备预配服务进行身份验证。</p>
  </li>
</ol>

<h4 id="任务-2配置模拟设备">任务 2：配置模拟设备</h4>

<p>在此任务中，将完成以下操作。</p>

<ul>
  <li>从 DPS 中获取要放入代码中的 ID 范围</li>
  <li>将下载的设备证书复制到应用程序的根文件夹中</li>
  <li>在 Visual Studio Code 中配置应用程序</li>
</ul>

<ol>
  <li>
    <p>在 Azure 门户中，打开“设备预配服务”并确保选中了 <strong>“概述”</strong> 窗格。</p>
  </li>
  <li>
    <p>在 <strong>“概述”</strong> 窗格中，复制设备预配服务的 <strong>“ID 范围”</strong>，并保存供以后参考。</p>

    <p>将鼠标悬停在值上方时，该值的右侧将显示一个“复制”按钮。</p>

    <p><strong>ID 范围</strong>类似于此值：<code>0ne0004E52G</code></p>
  </li>
  <li>
    <p>打开 Windows 文件资源管理器，然后导航到将 <code>sensor-thl-2000-device.cert.pfx</code> 证书文件下载到的文件夹。</p>
  </li>
  <li>
    <p>使用文件资源管理器创建 5 个设备证书文件的副本。</p>

    <p>现在复制全部五个证书文件可节省一些时间，但在最初构建的代码项目中，只使用第一个文件 <code>sensor-thl-2000-device.cert.pfx</code>。</p>
  </li>
  <li>
    <p>在文件资源管理器中，导航到实验室 6（在 DPS 中自动注册设备）的 Starter 文件夹。</p>

    <p>在“实验室 3：<em>设置开发环境</em>，你可以通过下载 ZIP 文件并从本地提取内容来克隆包含实验室资源的 GitHub 存储库。提取的文件夹结构包括以下文件夹路径：</p>

    <ul>
      <li>Allfiles
        <ul>
          <li>实验室
            <ul>
              <li>06 - 在 DPS 中自动注册设备
                <ul>
                  <li>入门
                    <ul>
                      <li>ContainerDevice</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>在打开的 ContainerDevice 文件夹中粘贴复制的设备证书文件。</p>

    <p>ContainerDevice 文件夹的根目录包含模拟设备应用的 <code>Program.cs</code> 文件。在向设备预配服务进行身份验证时，模拟设备项目会使用此证书文件。</p>
  </li>
  <li>
    <p>打开 <strong>Visual Studio Code</strong>。</p>
  </li>
  <li>
    <p>在 <strong>“文件”</strong> 菜单上，单击 <strong>“打开文件夹”</strong></p>
  </li>
  <li>
    <p>在 <strong>“打开文件夹”</strong> 对话框中，导航到实验室 6（在 DPS 中自动注册设备）的 Starter 文件夹。</p>
  </li>
  <li>
    <p>单击 <strong>“ContainerDevice”</strong>，然后单击 <strong>“选择文件夹”</strong>。</p>

    <p>你应该会在 Visual Studio Code 的资源管理器窗格中看到以下文件：</p>

    <ul>
      <li>ContainerDevice.csproj</li>
      <li>Program.cs</li>
      <li>sensor-thl-2000-device.cert.pfx</li>
    </ul>

    <p><strong>备注：</strong> 稍后将在本实验室中使用复制到此文件夹的其他设备证书文件，现在重点实现第一个设备证书文件。</p>
  </li>
  <li>
    <p>在 <strong>“资源管理器”</strong> 窗格中，单击 <strong>“ContainerDevice.csproj”</strong> 以打开“ContainerDevice.csproj”文件。</p>
  </li>
  <li>
    <p>在代码编辑器窗格的 <code>&lt;ItemGroup&gt;</code> 标记中，按如下方式更新证书文件名：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">xml</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock19" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock19" class="mt-0"><code class="language-xml hljs"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ItemGroup</span></span></span><span class="hljs-tag">&gt;</span></span>
     <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">None</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Update</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"sensor-thl-2000-device.cert.pfx"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">CopyToOutputDirectory</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"PreserveNewest"</span></span></span><span class="hljs-tag"> /&gt;</span></span>
     <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PackageReference</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Include</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Microsoft.Azure.Devices.Client"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Version</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1.*"</span></span></span><span class="hljs-tag"> /&gt;</span></span>
     <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PackageReference</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Include</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Microsoft.Azure.Devices.Provisioning.Transport.Mqtt"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Version</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1.*"</span></span></span><span class="hljs-tag"> /&gt;</span></span>
     <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PackageReference</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Include</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Microsoft.Azure.Devices.Provisioning.Transport.Amqp"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Version</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1.*"</span></span></span><span class="hljs-tag"> /&gt;</span></span>
     <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PackageReference</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Include</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Microsoft.Azure.Devices.Provisioning.Transport.Http"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Version</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1.*"</span></span></span><span class="hljs-tag"> /&gt;</span></span>
 <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ItemGroup</span></span></span><span class="hljs-tag">&gt;</span></span>
</code></pre>

    <p>这种配置可确保在编译 C# 代码时将 <code>sensor-thl-2000-device.cert.pfx</code> 证书文件复制到版本文件夹，并在程序执行时供其访问。</p>
  </li>
  <li>
    <p>在 Visual Studio Code 的 <strong>“文件”</strong> 菜单上，单击 <strong>“保存”</strong>。</p>

    <p><strong>备注：</strong> 如果 Visual Studio Code 代码提示执行“还原”操作，请立即执行。</p>
  </li>
  <li>
    <p>在 <strong>“资源管理器”</strong> 窗格中，单击 <strong>“Program.cs”</strong>。</p>

    <p>粗略地看一下就会发现，此版本的 <strong>ContainerDevice</strong> 应用程序实际上与上一个实验室中使用的版本基本相同。唯一的不同之处与使用 X.509 证书作为证明机制有关。从应用程序的角度来看，此设备是通过“组注册”还是通过“单独注册”来进行连接并不重要。</p>
  </li>
  <li>
    <p>找到 <strong>“GlobalDeviceEndpoint”</strong> 变量，并注意其值设置为 Azure 设备预配服务的全局设备终结点（<code>global.azure-devices-provisioning.net</code>）。</p>

    <p>在公共 Azure 云中，<strong>“global.azure-devices-provisioning.net”</strong> 是设备预配服务 (DPS) 的全局设备终结点。连接到 Azure DPS 的所有设备都将使用此全局设备终结点 DNS 名称进行配置。你应该会看到如下所示代码：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">c#</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock20" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock20" class="mt-0"><code class="language-csharp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> GlobalDeviceEndpoint = <span class="hljs-string"><span class="hljs-string">"global.azure-devices-provisioning.net"</span></span>;
</code></pre>
  </li>
  <li>
    <p>找到 <strong>“dpsIdScope”</strong> 变量，并用从设备预配服务的“概述”窗格中复制的<strong>ID 范围</strong>更新分配的值。</p>

    <p>当你更新完代码后，它应该类似于：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">c#</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock21" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock21" class="mt-0"><code class="language-csharp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> dpsIdScope = <span class="hljs-string"><span class="hljs-string">"0ne000CBD6C"</span></span>;
</code></pre>
  </li>
  <li>
    <p>找到 <strong>“certificateFileName”</strong> 变量，并注意其值设置为你生成的设备证书文件的默认名称 (<strong>new-device.cert.pfx</strong>)。</p>

    <p>这次应用程序使用 X.509 证书，而不是像之前的实验室中那样使用对称密钥。 <strong>“new-device.cert.pfx”</strong> 文件是在 Cloud Shell 中使用 <strong>certGen.sh</strong> 帮助程序脚本生成的 X.509 设备证书文件。此变量告知设备代码哪个文件包含 X.509 设备证书，设备将使用该证书向设备预配服务进行身份验证。</p>
  </li>
  <li>
    <p>按如下所示更新分配给 <strong>certificateFileName</strong> 变量的值：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">c#</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock22" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock22" class="mt-0"><code class="language-csharp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> certificateFileName = <span class="hljs-string"><span class="hljs-string">"sensor-thl-2000-device.cert.pfx"</span></span>;
</code></pre>
  </li>
  <li>
    <p>找到 <strong>“certificatePassword”</strong> 变量，注意此变量的值已设置为 <strong>“certGen.sh”</strong> 脚本的默认密码。</p>

    <p><strong>“certificatePassword”</strong> 变量包含 X.509 设备证书的密码。它设置为 <code>1234</code>，因为这是 <strong>“certGen.sh”</strong> 帮助程序脚本用于生成 X.509 证书的默认密码。</p>

    <blockquote>
      <p><strong>备注：</strong> 在本实验室中，密码是硬编码的。在_生产_方案中，需要以更安全的方式存储密码，例如存储在 Azure 密钥保管库中。此外，证书文件 (PFX) 应该使用硬件安全模块 (HSM) 安全地存储在生产设备上。</p>

      <p>HSM（硬件安全模块）用于安全的、基于硬件的设备机密存储，是最安全的机密存储形式。X.509 证书和 SAS 令牌都可以存储在 HSM 中。HSM 可以与预配服务支持的所有证明机制一起使用。本课程稍后将更详细地介绍 HMS。</p>
    </blockquote>
  </li>
</ol>

<h4 id="任务-3添加预配代码">任务 3：添加预配代码</h4>

<p>在此任务中，将输入用于完成实现的代码，这些实现与 Main 方法、设备预配、设备孪生属性相关。</p>

<ol>
  <li>
    <p>在 Program.cs 文件的代码编辑器窗格中，找到 <code>// 在下面插入 Main 方法</code> 注释。</p>
  </li>
  <li>
    <p>要实现 Main 方法，请输入以下代码：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">c#</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock23" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock23" class="mt-0"><code class="language-csharp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)
 </span></span>{
     X509Certificate2 certificate = LoadProvisioningCertificate();

     <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> security = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecurityProviderX509Certificate(certificate))
     <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transport = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProvisioningTransportHandlerAmqp(TransportFallbackType.TcpOnly))
     {
         ProvisioningDeviceClient provClient =
             ProvisioningDeviceClient.Create(GlobalDeviceEndpoint, dpsIdScope, security, transport);

         <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (deviceClient = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> ProvisionDevice(provClient, security))
         {
             <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> deviceClient.OpenAsync().ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>);

             <span class="hljs-comment"><span class="hljs-comment">// 在下方插入设置 OnDesiredPropertyChanged 事件处理</span></span>

             <span class="hljs-comment"><span class="hljs-comment">// 在下方插入加载设备孪生属性</span></span>

             <span class="hljs-comment"><span class="hljs-comment">// 开始读取和发送设备遥测</span></span>
             Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Start reading and sending device telemetry..."</span></span>);
             <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> SendDeviceToCloudMessagesAsync();

             <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> deviceClient.CloseAsync().ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>);
         }
     }
 }
</code></pre>

    <p>此 Main 方法与之前实验室中使用的方法非常相似。两个明显的不同之处是需要加载 X.509 证书，以及改为使用 <strong>SecurityProviderX509Certificate</strong> 作为安全提供程序。其余代码是相同的 - 你应该会注意到，还存在设备孪生属性更改代码。</p>
  </li>
  <li>
    <p>找到注释 <code>// INSERT LoadProvisioningCertificate method below here</code>。</p>
  </li>
  <li>
    <p>要实现 LoadProvisioningCertificate 方法，请插入以下代码：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">c#</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock24" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock24" class="mt-0"><code class="language-csharp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> X509Certificate2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadProvisioningCertificate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)
 </span></span>{
     <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> certificateCollection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X509Certificate2Collection();
     certificateCollection.Import(certificateFileName, certificatePassword, X509KeyStorageFlags.UserKeySet);

     X509Certificate2 certificate = <span class="hljs-literal"><span class="hljs-literal">null</span></span>;

     <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (X509Certificate2 element <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> certificateCollection)
     {
         Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Found certificate: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{element?.Thumbprint}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{element?.Subject}</span></span></span><span class="hljs-string">; PrivateKey: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{element?.HasPrivateKey}</span></span></span><span class="hljs-string">"</span></span>);
         <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (certificate == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; element.HasPrivateKey)
         {
             certificate = element;
         }
         <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>
         {
             element.Dispose();
         }
     }

     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (certificate == <span class="hljs-literal"><span class="hljs-literal">null</span></span>)
     {
         <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileNotFoundException(<span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{certificateFileName}</span></span></span><span class="hljs-string"> did not contain any certificate with a private key."</span></span>);
     }

     Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Using certificate </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{certificate.Thumbprint}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{certificate.Subject}</span></span></span><span class="hljs-string">"</span></span>);
     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> certificate;
 }
</code></pre>

    <p>从名称就可以看出，此方法的作用是从磁盘加载 X.509 证书。如果加载成功，该方法将返回 <strong>X509Certificate2</strong> 类的实例。</p>

    <blockquote>
      <p><strong>信息</strong>： 你可能会好奇为什么结果是 <strong>X509Certificate2</strong> 类型而不是 <strong>X509Certificate</strong>。 <strong>X509Certificate</strong> 是较早的实现，其功能受到限制。 <strong>X509Certificate2</strong> 是 <strong>X509Certificate</strong> 的一个子类，具有支持 X509 标准 V2 和 V3 的附加功能。</p>
    </blockquote>

    <p>该方法创建 <strong>X509Certificate2Collection</strong> 类的实例，然后尝试使用硬编码密码从磁盘导入证书文件。 <strong>X509KeyStorageFlags.UserKeySet</strong> 值指定将私钥存储在当前用户存储中，而不是本地计算机存储中。即使证书指定应将密钥存放在本地计算机存储中，也不会改变上述结果。</p>

    <p>接下来，该方法遍历导入的证书（本例中应只有一个证书），并验证证书是否具有私钥。如果导入的证书与此条件不匹配，将引发异常，如果不是这种情况，则该方法返回导入的证书。</p>
  </li>
  <li>
    <p>找到 <code>// INSERT ProvisionDevice method below here</code> 注释。</p>
  </li>
  <li>
    <p>要实现 ProvisionDevice方法，请输入以下代码：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">c#</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock25" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock25" class="mt-0"><code class="language-csharp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;DeviceClient&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProvisionDevice</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ProvisioningDeviceClient provisioningDeviceClient, SecurityProviderX509Certificate security</span></span></span><span class="hljs-function">)
 </span></span>{
     <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> provisioningDeviceClient.RegisterAsync().ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>);
     Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"ProvisioningClient AssignedHub: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{result.AssignedHub}</span></span></span><span class="hljs-string">; DeviceID: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{result.DeviceId}</span></span></span><span class="hljs-string">"</span></span>);
     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.Status != ProvisioningRegistrationStatusType.Assigned)
     {
         <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">$"DeviceRegistrationResult.Status is NOT 'Assigned'"</span></span>);
     }

     <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> auth = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeviceAuthenticationWithX509Certificate(
         result.DeviceId,
         security.GetAuthenticationCertificate());

     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DeviceClient.Create(result.AssignedHub, auth, TransportType.Amqp);
 }
</code></pre>

    <p>此版本的 <strong>ProvisionDevice</strong> 与之前实验室中使用的非常相似。主要的不同之处在于 <strong>security</strong> 参数现在的类型为 <strong>SecurityProviderX509Certificate</strong>。这意味着用于创建 <strong>DeviceClient</strong> 的 auth 变量现在必须是 <strong>DeviceAuthenticationWithX509Certificate</strong> 类型，并使用 <code>security.GetAuthenticationCertificate()</code> 值。实际的设备注册与之前相同。</p>
  </li>
</ol>

<h4 id="任务-4添加设备孪生集成代码">任务 4：添加设备孪生集成代码</h4>

<p>要使用设备上的设备孪生属性（来自 Azure IoT 中心），需要创建访问和应用设备孪生属性的代码。在这种情况下，可能要更新模拟设备代码以读取设备孪生“所需属性”，然后将该值分配给 <strong>“telemetryDelay”</strong> 变量。可能还要更新设备孪生报告的属性，以指示当前在设备上实现的延迟值。</p>

<ol>
  <li>
    <p>在 Visual Studio Code 编辑器中，找到 <strong>Main</strong> 方法。</p>
  </li>
  <li>
    <p>花一些时间查看代码，找到注释 <code>// INSERT Setup OnDesiredPropertyChanged Event Handling below here</code>。</p>

    <p>要开始集成设备孪生属性，需要在设备孪生属性更新时能够通知模拟设备的代码。</p>

    <p>为实现此目的，可以使用 <strong>“DeviceClient.SetDesiredPropertyUpdateCallbackAsync”</strong> 方法，并通过创建 <strong>“OnDesiredPropertyChanged”</strong> 方法来设置事件处理程序。</p>
  </li>
  <li>
    <p>要为 OnDesiredPropertyChanged 事件设置 DeviceClient，请输入以下代码：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">c#</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock26" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock26" class="mt-0"><code class="language-csharp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> deviceClient.SetDesiredPropertyUpdateCallbackAsync(OnDesiredPropertyChanged, <span class="hljs-literal"><span class="hljs-literal">null</span></span>).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>);
</code></pre>

    <p><strong>SetDesiredPropertyUpdateCallbackAsync</strong> 方法用于设置 <strong>DesiredPropertyUpdateCallback</strong> 事件处理程序来接收设备孪生所需的属性更改。当接收到设备孪生属性更改事件时，此代码将 <strong>deviceClient</strong> 配置为调用名为 <strong>OnDesiredPropertyChanged</strong> 的方法。</p>

    <p>现在已经有了 <strong>SetDesiredPropertyUpdateCallbackAsync</strong> 方法来设置事件处理程序，你需要创建它调用的 <strong>OnDesiredPropertyChanged</strong> 方法。</p>
  </li>
  <li>
    <p>找到 <code>// INSERT OnDesiredPropertyChanged method below here</code> 注释。</p>
  </li>
  <li>
    <p>若要完成事件处理程序的设置，请输入以下代码：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">c#</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock27" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock27" class="mt-0"><code class="language-csharp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDesiredPropertyChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TwinCollection desiredProperties, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userContext</span></span></span><span class="hljs-function">)
 </span></span>{
     Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Desired Twin Property Changed:"</span></span>);
     Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{desiredProperties.ToJson()}</span></span></span><span class="hljs-string">"</span></span>);

     <span class="hljs-comment"><span class="hljs-comment">// 读取所需孪生属性</span></span>
     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (desiredProperties.Contains(<span class="hljs-string"><span class="hljs-string">"telemetryDelay"</span></span>))
     {
         <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> desiredTelemetryDelay = desiredProperties[<span class="hljs-string"><span class="hljs-string">"telemetryDelay"</span></span>];
         <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (desiredTelemetryDelay != <span class="hljs-literal"><span class="hljs-literal">null</span></span>)
         {
             telemetryDelay = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.Parse(desiredTelemetryDelay);
         }
         <span class="hljs-comment"><span class="hljs-comment">// 如果所需 TelemetryDelay 为 null 或未指定，请勿更改</span></span>
     }

     <span class="hljs-comment"><span class="hljs-comment">// 报告孪生属性</span></span>
     <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> reportedProperties = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TwinCollection();
     reportedProperties[<span class="hljs-string"><span class="hljs-string">"telemetryDelay"</span></span>] = telemetryDelay.ToString();
     <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> deviceClient.UpdateReportedPropertiesAsync(reportedProperties).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>);
     Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Reported Twin Properties:"</span></span>);
     Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{reportedProperties.ToJson()}</span></span></span><span class="hljs-string">"</span></span>);
 }
</code></pre>

    <p>注意， <strong>OnDesiredPropertyChanged</strong> 事件处理程序接受类型为 <strong>TwinCollection</strong> 的 <strong>desiredProperties</strong> 参数。</p>

    <p>注意，如果 <strong>desiredProperties</strong>参数的值包含 <strong>telemetryDelay</strong> （设备孪生所需属性），则代码会将设备孪生属性的值分配给 <strong>telemetryDelay</strong> 变量。你可能还记得， <strong>“SendDeviceToCloudMessagesAsync”</strong> 方法包括一个 <strong>“Task.Delay”</strong> 调用，该调用使用 <strong>“telemetryDelay”</strong> 变量来设置发送到 IoT 中心的消息之间的延迟时间。</p>

    <p>请注意，下一个代码块用于将设备的当前状态报告回 Azure IoT 中心。此代码会调用 <strong>DeviceClient.UpdateReportedPropertiesAsync</strong> 方法并将其传递给 <strong>TwinCollection</strong>，其中包含设备属性的当前状态。这是设备向 IoT 中心报告的方式，它已收到设备孪生期望属性更改事件，并且现在已相应更新其配置。请注意，它报告的是现在设置的属性，而不是所需属性的回显。如果从设备发送的报告属性不同于设备接收到的所需状态，则 IoT 中心将保持反映设备状态的准确设备孪生。</p>

    <p>既然设备可以从 Azure IoT 中心接收对设备孪生所需属性的更新，则还需要对其进行编码以在设备启动时配置其初始设置。为此，设备将需要从 Azure IoT 中心加载当前设备孪生所需属性，并进行相应的配置。</p>
  </li>
  <li>
    <p>在 <strong>Main</strong> 方法中，找到 <code>// INSERT Load Device Twin Properties below here</code> 注释。</p>
  </li>
  <li>
    <p>要读取设备孪生所需属性并配置设备使其在设备启动时匹配，请输入以下代码：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">c#</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock28" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock28" class="mt-0"><code class="language-csharp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> twin = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> deviceClient.GetTwinAsync().ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>);
 <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> OnDesiredPropertyChanged(twin.Properties.Desired, <span class="hljs-literal"><span class="hljs-literal">null</span></span>);
</code></pre>

    <p>此代码调用 <strong>“DeviceTwin.GetTwinAsync”</strong> 方法来为模拟设备检索设备孪生。然后，它访问 <strong>“Properties.Desired”</strong> 属性对象以检索设备的当前所需状态，并将其传递给用于配置模拟设备的 <strong>“telemetryDelay”</strong> 变量的 <strong>“OnDesiredPropertyChanged”</strong> 方法。</p>

    <p>请注意，此代码会重复使用已创建用于处理 <strong>OnDesiredPropertyChanged</strong>  事件的 <em>OnDesiredPropertyChanged</em> 方法。这有助于将读取设备孪生所需状态属性和在启动时配置该设备的代码保存在单一位置中。生成的代码更简单，更易于维护。</p>
  </li>
  <li>
    <p>在 Visual Studio Code 的 <strong>“文件”</strong> 菜单上，单击 <strong>“保存”</strong>。</p>

    <p>模拟设备当前将使用 Azure IoT 中心的设备孪生属性来设置遥测消息之间的延迟。</p>
  </li>
  <li>
    <p>在 <strong>“终端”</strong> 菜单中，单击 <strong>“新建终端”</strong>。</p>
  </li>
  <li>
    <p>在终端命令提示符下，输入 <strong>“dotnet build”</strong> 可验证代码是否能正确生成</p>

    <p>如果列出了生成错误，请在继续下一个练习之前先将其解决。如果需要，请咨询讲师。</p>
  </li>
</ol>

<h3 id="练习-4创建更多模拟设备实例">练习 4：创建更多模拟设备实例</h3>

<p>在本练习中，将制作模拟设备项目的副本，然后更新代码以使用创建并添加到项目文件夹中的不同设备证书。</p>

<h4 id="任务-1创建代码项目的副本">任务 1：创建代码项目的副本</h4>

<ol>
  <li>
    <p>打开 Windows 文件资源管理器。</p>
  </li>
  <li>
    <p>在文件资源管理器中，导航到实验室 6（在 DPS 中自动注册设备）的 Starter 文件夹。</p>

    <p>在“实验室 3：<em>设置开发环境</em>，你可以通过下载 ZIP 文件并从本地提取内容来克隆包含实验室资源的 GitHub 存储库。提取的文件夹结构包括以下文件夹路径：</p>

    <ul>
      <li>Allfiles
        <ul>
          <li>实验室
            <ul>
              <li>06 - 在 DPS 中自动注册设备
                <ul>
                  <li>入门</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>右键单击 <strong>“ContainerDevice”</strong>，然后单击 <strong>“复制”</strong>。</p>

    <p>ContainerDevice 文件夹应为包含模拟设备代码的文件夹。</p>
  </li>
  <li>
    <p>在 <strong>“ContainerDevice”</strong> 下面的空白处单击鼠标右键，然后单击 <strong>“粘贴”</strong></p>

    <p>应会看到已创建名为“ContainerDevice - Copy”的文件夹。</p>
  </li>
  <li>
    <p>右键单击 <strong>“ContainerDevice - Copy”</strong>，单击 <strong>“重命名”</strong>，然后键入 <strong>“ContainerDevice2001”</strong></p>
  </li>
  <li>
    <p>重复步骤 3-5，创建具有以下名称的文件夹：</p>

    <ul>
      <li><strong>ContainerDevice2002</strong></li>
      <li><strong>ContainerDevice2003</strong></li>
      <li><strong>ContainerDevice2004</strong></li>
    </ul>
  </li>
</ol>

<h4 id="任务-2更新代码项目中的证书文件引用">任务 2：更新代码项目中的证书文件引用</h4>

<ol>
  <li>
    <p>如有必要，打开 Visual Studio Code。</p>
  </li>
  <li>
    <p>在 <strong>“文件”</strong> 菜单上，单击 <strong>“打开文件夹”</strong>。</p>
  </li>
  <li>
    <p>导航到“lab 6 Starter”文件夹。</p>
  </li>
  <li>
    <p>单击 <strong>“ContainerDevice2001”</strong>，然后单击 <strong>“选择文件夹”</strong>。</p>
  </li>
  <li>
    <p>在“资源管理器”窗格中，单击 <strong>“Program.cs”</strong>。</p>
  </li>
  <li>
    <p>在代码编辑器中，找到 <strong>certificateFileName</strong> 变量，按如下所示更新分配给 <strong>certificateFileName</strong> 变量的值：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">c#</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock29" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock29" class="mt-0"><code class="language-csharp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> certificateFileName = <span class="hljs-string"><span class="hljs-string">"sensor-thl-2001-device.cert.pfx"</span></span>;
</code></pre>
  </li>
  <li>
    <p>在 <strong>“资源管理器”</strong> 窗格中，单击 <strong>“ContainerDevice.csproj”</strong> 以打开“ContainerDevice.csproj”文件。</p>
  </li>
  <li>
    <p>在代码编辑器窗格的 <code>&lt;ItemGroup&gt;</code> 标记中，按如下方式更新证书文件名：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">xml</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock30" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock30" class="mt-0"><code class="language-xml hljs"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ItemGroup</span></span></span><span class="hljs-tag">&gt;</span></span>
     <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">None</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Update</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"sensor-thl-2001-device.cert.pfx"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">CopyToOutputDirectory</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"PreserveNewest"</span></span></span><span class="hljs-tag"> /&gt;</span></span>
     <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PackageReference</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Include</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Microsoft.Azure.Devices.Client"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Version</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1.*"</span></span></span><span class="hljs-tag"> /&gt;</span></span>
     <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PackageReference</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Include</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Microsoft.Azure.Devices.Provisioning.Transport.Mqtt"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Version</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1.*"</span></span></span><span class="hljs-tag"> /&gt;</span></span>
     <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PackageReference</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Include</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Microsoft.Azure.Devices.Provisioning.Transport.Amqp"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Version</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1.*"</span></span></span><span class="hljs-tag"> /&gt;</span></span>
     <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PackageReference</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Include</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Microsoft.Azure.Devices.Provisioning.Transport.Http"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Version</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1.*"</span></span></span><span class="hljs-tag"> /&gt;</span></span>
 <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ItemGroup</span></span></span><span class="hljs-tag">&gt;</span></span>
</code></pre>
  </li>
  <li>
    <p>在 <strong>“文件”</strong> 菜单上，单击 <strong>“全部保存”</strong>。</p>
  </li>
  <li>
    <p>重复上述步骤 3-9，为每个剩余代码项目更新 <strong>Program.cs</strong> 和 <strong>ContainerDevice.csproj</strong> 文件，如下所示：</p>

    <table>
      <thead>
        <tr>
          <th>项目文件夹</th>
          <th>证书名称</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>ContainerDevice2002</td>
          <td>sensor-thl-2002-device.cert.pfx</td>
        </tr>
        <tr>
          <td>ContainerDevice2003</td>
          <td>sensor-thl-2003-device.cert.pfx</td>
        </tr>
        <tr>
          <td>ContainerDevice2004</td>
          <td>sensor-thl-2004-device.cert.pfx</td>
        </tr>
      </tbody>
    </table>

    <p><strong>备注：</strong> 在为下一个文件夹执行之前，请确保每次都选择了 <strong>“全部保存”</strong>。</p>
  </li>
</ol>

<h3 id="练习-5测试模拟设备">练习 5：测试模拟设备</h3>

<p>在本练习中，你将运行模拟设备。首次启动设备时，它将连接到设备预配服务 (DPS)，并使用配置的组注册自动注册。注册 DPS 组注册后，设备将自动在 Azure IoT 中心设备注册表中注册。注册并登记后，设备将开始使用配置的 X.509 证书身份验证与 Azure IoT 中心安全通信。</p>

<h4 id="任务-1生成并运行模拟设备项目">任务 1：生成并运行模拟设备项目</h4>

<ol>
  <li>
    <p>确保已打开 Visual Studio Code。</p>
  </li>
  <li>
    <p>在 <strong>“文件”</strong> 菜单上，单击 <strong>“打开文件夹”</strong>。</p>
  </li>
  <li>
    <p>导航到“lab 6 Starter”文件夹。</p>
  </li>
  <li>
    <p>单击 <strong>“ContainerDevice”</strong>，然后单击 <strong>“选择文件夹”</strong>。</p>
  </li>
  <li>
    <p>在 <strong>“查看”</strong> 菜单中，单击 <strong>“终端”</strong>。</p>

    <p>这将在 Visual Studio Code 窗口的底部打开集成终端。</p>
  </li>
  <li>
    <p>在终端命令提示符下，确保将当前目录路径设置为 <code>\ContainerDevice</code> 文件夹。</p>

    <p>你应该会看到以下类似内容：</p>

    <p><code>Allfiles\Labs\06-Automatic Enrollment of Devices in DPS\Starter\ContainerDevice&gt;</code></p>
  </li>
  <li>
    <p>要生成并运行 <strong>“ContainerDevice”</strong> 项目，请输入以下命令：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">code</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock31" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock31" class="mt-0"><code class="language-cmd/sh"> dotnet run
</code></pre>

    <blockquote>
      <p><strong>备注：</strong>  第一次运行模拟设备时，最常见的错误是 <em>“证书无效”</em> 错误。如果显示 <code>ProvisioningTransportException</code> 异常，则最可能是由于此错误造成的。如果看到与下面所示类似的消息，在继续操作之前需要先确保 DPS 中的 CA 证书和模拟设备应用程序的设备证书配置正确。</p>

      <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">code</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock32" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock32" class="mt-0"><code class="language-text">localmachine:LabFiles User$ dotnet run
Found certificate: AFF851ED016CA5AEB71E5749BCBE3415F8CF4F37 CN=sensor-thl-2000; PrivateKey: True
Using certificate AFF851ED016CA5AEB71E5749BCBE3415F8CF4F37 CN=sensor-thl-2000
RegistrationID = sensor-thl-2000
ProvisioningClient RegisterAsync . . . Unhandled exception. Microsoft.Azure.Devices.Provisioning.Client.ProvisioningTransportException: {"errorCode":401002,"trackingId":"2e298c80-0974-493c-9fd9-6253fb055ade","message":"Invalid certificate.","timestampUtc":"2019-12-13T14:55:40.2764134Z"}
  at Microsoft.Azure.Devices.Provisioning.Client.Transport.ProvisioningTransportHandlerAmqp.ValidateOutcome(Outcome outcome)
  at Microsoft.Azure.Devices.Provisioning.Client.Transport.ProvisioningTransportHandlerAmqp.RegisterDeviceAsync(AmqpClientConnection client, String correlationId, DeviceRegistration deviceRegistration)
  at Microsoft.Azure.Devices.Provisioning.Client.Transport.ProvisioningTransportHandlerAmqp.RegisterAsync(ProvisioningTransportRegisterMessage message, CancellationToken cancellationToken)
  at X509CertificateContainerDevice.ProvisioningDeviceLogic.RunAsync() in /Users/User/Documents/AZ-220/LabFiles/Program.cs:line 121
  at X509CertificateContainerDevice.Program.Main(String[] args) in /Users/User/Documents/AZ-220/LabFiles/Program.cs:line 55
...
</code></pre>
    </blockquote>
  </li>
  <li>
    <p>请注意，模拟设备应用将输出发送到终端窗口。</p>

    <p>如果模拟设备应用程序运行正常，<strong>终端</strong>会显示来自应用的控制台输出。</p>

    <p>向上滚动到“终端”窗口中显示的信息的顶部。</p>

    <p>请注意，已加载 X.509 证书，已在设备预配服务中注册设备，并已分配证书用于连接到 <strong>iot-az220-training-{your-id}</strong> IoT 中心，现已加载设备孪生所需属性。</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">code</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock33" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock33" class="mt-0"><code class="language-text"> localmachine:LabFiles User$ dotnet run
 Found certificate: AFF851ED016CA5AEB71E5749BCBE3415F8CF4F37 CN=sensor-thl-2000; PrivateKey: True
 Using certificate AFF851ED016CA5AEB71E5749BCBE3415F8CF4F37 CN=sensor-thl-2000
 RegistrationID = sensor-thl-2000
 ProvisioningClient RegisterAsync . . . Device Registration Status: Assigned
 ProvisioningClient AssignedHub: iot-az220-training-CP1119.azure-devices.net; DeviceID: sensor-thl-2000
 Creating X509 DeviceClient authentication.
 simulated device. Ctrl-C to exit.
 DeviceClient OpenAsync.
 Connecting SetDesiredPropertyUpdateCallbackAsync event handler...
 Loading Device Twin Properties...
 Desired Twin Property Changed:
 {"$version":1}
 Reported Twin Properties:
 {"telemetryDelay":1}
 Start reading and sending device telemetry...
</code></pre>

    <p>要查看模拟设备的源代码，请打开 <code>Program.cs</code> 源代码文件。查找几个 <code>Console.WriteLine</code> 语句，这些语句用于将看到的消息输出到控制台。</p>
  </li>
  <li>
    <p>请注意，JSON 格式的遥测消息已发送到 Azure IoT 中心。</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">code</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock34" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock34" class="mt-0"><code class="language-text"> Start reading and sending device telemetry...
 12/9/2019 5:47:00 PM &gt; Sending message: {"temperature":24.047539159212047,"humidity":67.00504162675004,"pressure":1018.8478924248358,"latitude":40.129349260196875,"longitude":-98.42877188146265}
 12/9/2019 5:47:01 PM &gt; Sending message: {"temperature":26.628804161040485,"humidity":68.09610794675355,"pressure":1014.6454375411363,"latitude":40.093269544242695,"longitude":-98.22227128174003}
</code></pre>

    <p>模拟设备通过初始启动后，它将开始向 Azure IoT 中心发送模拟传感器遥测消息。</p>

    <p>请注意，发送到 IoT 中心的每条消息之间的延迟（由 <code>telemetryDelay</code> 设备孪生属性定义）当前正是在发送传感器遥测消息之间的延迟 <strong>1 秒</strong> 。</p>
  </li>
  <li>
    <p>使模拟设备保持运行。</p>
  </li>
</ol>

<h4 id="任务-2启动其他模拟设备">任务 2：启动其他模拟设备</h4>

<ol>
  <li>
    <p>打开一个新的 Visual Studio Code 实例。</p>

    <p>可以通过 Windows 10 的“开始”菜单执行此操作，如下所示：在 Windows 10 的 <strong>“开始”</strong> 菜单上，右键单击 <strong>Visual Studio Code</strong>，然后单击 <strong>“新窗口”</strong>。</p>
  </li>
  <li>
    <p>在新 Visual Studio Code 窗口中的 <strong>“文件”</strong> 菜单上，单击 <strong>“打开文件夹”</strong>。</p>
  </li>
  <li>
    <p>导航到“lab 6 Starter”文件夹。</p>
  </li>
  <li>
    <p>单击 <strong>“ContainerDevice2001”</strong>，然后单击 <strong>“选择文件夹”</strong>。</p>
  </li>
  <li>
    <p>在 <strong>“查看”</strong> 菜单中，单击 <strong>“终端”</strong>。</p>

    <p>这将在 Visual Studio Code 窗口的底部打开集成终端。</p>
  </li>
  <li>
    <p>在终端命令提示符下，确保将当前目录路径设置为 <code>\ContainerDevice2001</code> 文件夹。</p>

    <p>你应该会看到以下类似内容：</p>

    <p><code>Allfiles\Labs\06-Automatic Enrollment of Devices in DPS\Starter\ContainerDevice2001&gt;</code></p>
  </li>
  <li>
    <p>要生成并运行 <strong>“ContainerDevice”</strong> 项目，请输入以下命令：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">code</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock35" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock35" class="mt-0"><code class="language-cmd/sh"> dotnet run
</code></pre>
  </li>
  <li>
    <p>重复上述步骤 1-7，打开并启动其他模拟设备项目，如下所示：</p>

    <table>
      <thead>
        <tr>
          <th>项目文件夹</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>ContainerDevice2002</td>
        </tr>
        <tr>
          <td>ContainerDevice2003</td>
        </tr>
        <tr>
          <td>ContainerDevice2004</td>
        </tr>
      </tbody>
    </table>
  </li>
</ol>

<h4 id="任务-3通过孪生更改设备配置">任务 3：通过孪生更改设备配置</h4>

<p>当模拟设备处于运行状态下时，可以通过在 Azure IoT 中心内编辑设备孪生所需状态来更新 <code>telemetryDelay</code> 配置。</p>

<ol>
  <li>
    <p>打开 <strong>Azure 门户</strong>，然后导航到 <strong>“Azure IoT 中心”</strong> 服务。</p>
  </li>
  <li>
    <p>在“IoT 中心”边栏选项卡左侧菜单中的 <strong>“资源管理器”</strong> 下，单击 <strong>“IoT 设备”</strong>。</p>
  </li>
  <li>
    <p>在 IoT 设备列表中，单击 <strong>“sensor-thl-2000”</strong>。</p>

    <blockquote>
      <p><strong>重要说明</strong>： 确保从此实验中选择设备。可能还会看到在课程早期创建的名为 <em>“sensor-th-0001”</em> 的设备。</p>
    </blockquote>
  </li>
  <li>
    <p>在 <strong>“sensor-thl-2000”</strong> 设备边栏选项卡的顶部，单击 <strong>“设备孪生”</strong>。</p>

    <p>在 <strong>“设备孪生”</strong> 边栏选项卡上，有一个编辑器带有设备孪生的完整 JSON 。这使你能够直接在 Azure 门户中查看和/或编辑设备孪生状态。</p>
  </li>
  <li>
    <p>在设备孪生 JSON 中找到 <code>properties.desired</code> 节点。</p>
  </li>
  <li>
    <p>更新 <code>telemetryDelay</code> 属性，使其值为 <code>“2”</code>。</p>

    <p>这将更新模拟设备的 <code>telemetryDelay</code>，变为每隔 <strong>2 秒</strong> 发送一次传感器遥测。</p>

    <p>为此部分设备孪生所需属性生成的 JSON 将类似于以下内容：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">code</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock36" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock36" class="mt-0"><code class="language-json hljs"> <span class="hljs-string"><span class="hljs-string">"properties"</span></span>: {
     <span class="hljs-attr"><span class="hljs-attr">"desired"</span></span>: {
       <span class="hljs-attr"><span class="hljs-attr">"telemetryDelay"</span></span>: <span class="hljs-string"><span class="hljs-string">"2"</span></span>,
       <span class="hljs-attr"><span class="hljs-attr">"$metadata"</span></span>: {
         <span class="hljs-attr"><span class="hljs-attr">"$lastUpdated"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-09T22:48:05.9703541Z"</span></span>,
         <span class="hljs-attr"><span class="hljs-attr">"$lastUpdatedVersion"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>,
         <span class="hljs-attr"><span class="hljs-attr">"telemetryDelay"</span></span>: {
           <span class="hljs-attr"><span class="hljs-attr">"$lastUpdated"</span></span>: <span class="hljs-string"><span class="hljs-string">"2019-12-09T22:48:05.9703541Z"</span></span>,
           <span class="hljs-attr"><span class="hljs-attr">"$lastUpdatedVersion"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>
         }
       },
       <span class="hljs-attr"><span class="hljs-attr">"$version"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>
     },
</code></pre>

    <p>在 JSON 中保留 <code>properties.desired</code> 节点的 <code>$metadata</code> 和 <code>$version</code> 值。你只应更新 <code>telemetryDelay</code> 值以设置新设备孪生所需属性值。</p>
  </li>
  <li>
    <p>在边栏选项卡顶部，单击 <strong>“保存”</strong>，为设备应用设备孪生所需属性。</p>

    <p>保存后，更新后的设备孪生所需属性将自动发送到模拟设备。</p>
  </li>
  <li>
    <p>切换回包含原始 <strong>ContainerDevice</strong> 项目的 <strong>Visual Studio Code</strong> 窗口。</p>
  </li>
  <li>
    <p>请注意，应用程序已收到有关更新的设备孪生 <code>telemetryDelay</code> 所需属性设置的通知。</p>

    <p>该应用程序向控制台输出消息，表明已加载新设备孪生所需属性，并且已设置更改并将其报告回 Azure IoT 中心。</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">code</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock37" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock37" class="mt-0"><code class="language-text"> Desired Twin Property Changed:
 {"telemetryDelay":2,"$version":2}
 Reported Twin Properties:
 {"telemetryDelay":2}
</code></pre>
  </li>
  <li>
    <p>请注意，模拟设备传感器遥测消息现在每隔 <em>2</em> 秒发送到 Azure IoT 中心。</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">code</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock38" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock38" class="mt-0"><code class="language-text"> 12/9/2019 5:48:07 PM &gt; Sending message: {"temperature":33.89822140284731,"humidity":78.34939097908763,"pressure":1024.9467544610131,"latitude":40.020042418755764,"longitude":-98.41923808825841}
 12/9/2019 5:48:09 PM &gt; Sending message: {"temperature":27.475786026323114,"humidity":64.4175510594703,"pressure":1020.6866468579678,"latitude":40.2089999240047,"longitude":-98.26223221770334}
 12/9/2019 5:48:11 PM &gt; Sending message: {"temperature":34.63600901637041,"humidity":60.95207713588703,"pressure":1013.6262313688063,"latitude":40.25499096898331,"longitude":-98.51199886959347}
</code></pre>
  </li>
  <li>
    <p>在 <strong>“终端”</strong> 窗口中，按 <strong>“Ctrl-C”</strong> 退出模拟设备应用。</p>
  </li>
  <li>
    <p>切换到每个 Visual Studio Code 窗口，然后使用<strong>终端</strong>提示符关闭模拟设备应用。</p>
  </li>
  <li>
    <p>切换 Azure 门户窗口。</p>
  </li>
  <li>
    <p>关闭 <strong>“设备孪生”</strong> 边栏选项卡。</p>
  </li>
  <li>
    <p>在 sensor-thl-2000 边栏选项卡上，单击 <strong>“设备孪生”</strong>。</p>
  </li>
  <li>
    <p>向下滚动以找到 <code>properties.reported</code> 对象的 JSON。</p>

    <p>这包含设备报告的状态。</p>
  </li>
  <li>
    <p>注意，这里还有 <code>telemetryDelay</code> 属性，并且也设置为 <code>2</code>。</p>

    <p>还有一个 <code>$metadata</code> 值，用于显示 <code>reported</code> 值上次更新的时间。</p>
  </li>
  <li>
    <p>再次关闭 <strong>“设备孪生”</strong> 边栏选项卡。</p>
  </li>
  <li>
    <p>关闭 <strong>“sensor-thl-2000”</strong> 边栏选项卡，然后导航回到 Azure 门户仪表板。</p>
  </li>
</ol>

<h3 id="练习-5从注册组取消预配单个设备">练习 5：从“注册组”取消预配单个设备</h3>

<p>有许多原因可能导致需要取消预配一部分在组注册中注册的设备。例如，可能不再需要某个设备，有一个更新版本的设备可用，或某个设备可能已损坏或遭入侵。</p>

<p>要从注册组中取消预配单个设备，必须执行两项操作：</p>

<ul>
  <li>
    <p>为设备叶（设备）证书创建一个禁用的单独注册。</p>

    <p>这会撤销该设备对预配服务的访问权限，同时仍允许链中具有注册组签名证书的其他设备访问。请注意，不要删除设备的禁用的单独注册，因为这样做会使设备能够通过注册组来重新注册。</p>
  </li>
  <li>
    <p>从 IoT 中心的标识注册表中禁用或删除设备。</p>

    <p>如果解决方案包含多个 IoT 中心，应使用注册组的预配设备的列表来查找设备预配到的 IoT 中心（以便可以禁用或删除设备）。在本例中，只有一个 IoT 中心，因此不需要查找使用了哪个 IoT 中心。</p>
  </li>
</ul>

<p>在本练习中，将从注册组中取消预配单个设备。</p>

<h4 id="任务-1为设备创建禁用的单独注册">任务 1：为设备创建禁用的单独注册。</h4>

<p>在本任务中，将使用 <strong>sensor-thl-2004</strong> 设备进行单独注册。</p>

<ol>
  <li>
    <p>如有必要，请使用 Azure 帐户凭据登录到 Azure 门户。</p>

    <p>如果有多个 Azure 帐户，请确保使用与本课程要使用的订阅绑定的帐户登录。</p>
  </li>
  <li>
    <p>在 Azure 门户工具栏上，单击 <strong>“Cloud Shell”</strong></p>

    <p>Azure 门户工具栏贯穿门户窗口的顶部。Cloud Shell 按钮是自右往左的第 6 项。</p>
  </li>
  <li>
    <p>验证 Cloud Shell 是否在使用 <strong>Bash</strong>。</p>

    <p>Azure Cloud Shell 页面左上角的下拉菜单用于选择环境。验证所选的下拉值是否为 <strong>Bash</strong>。</p>
  </li>
  <li>
    <p>在 Cloud Shell 命令提示符处，输入以下命令可导航到 <code>~/certificates</code> 目录：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">shell</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock39" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock39" class="mt-0"><code class="language-sh hljs bash"> <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ~/certificates
</code></pre>
  </li>
  <li>
    <p>要将 .pem 设备证书从 Cloud Shell 下载到本地计算机，请输入以下命令：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">shell</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock40" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock40" class="mt-0"><code class="language-sh hljs bash"> download ~/certificates/certs/sensor-thl-2004-device.cert.pem
</code></pre>
  </li>
  <li>
    <p>切换到 Azure 仪表板。</p>
  </li>
  <li>
    <p>在“资源”磁贴上，单击 <strong>“dps-az220-training-{your-id}”</strong>。</p>
  </li>
  <li>
    <p>在 DPS 边栏选项卡左侧菜单中的 <strong>“设置”</strong> 下，单击 <strong>“管理注册”</strong>。</p>
  </li>
  <li>
    <p>在 <strong>“管理注册”</strong> 窗格中，单击 <strong>“添加单独注册”</strong>。</p>
  </li>
  <li>
    <p>在 <strong>“添加注册”</strong> 边栏选项卡中的 <strong>“机制”</strong> 下，确保选中 <strong>“X.509”</strong>。</p>
  </li>
  <li>
    <p>在 <strong>“主证书 .pem 或 .cer 文件”</strong> 下，单击 <strong>“打开”</strong>。</p>
  </li>
  <li>
    <p>在 <strong>“打开”</strong> 对话框中，导航到 downloads 文件夹。</p>
  </li>
  <li>
    <p>在 downloads 文件夹中，单击 <strong>“sensor-thl-2004-device.cert.pem”</strong>，然后单击 <strong>“打开”</strong>。</p>
  </li>
  <li>
    <p>在 <strong>“添加注册”</strong> 边栏选项卡的 <strong>“IoT 中心设备 ID”</strong> 下，输入 <strong>“sensor-th-2004”</strong></p>
  </li>
  <li>
    <p>在 <strong>“启用条目”</strong> 下，单击 <strong>“禁用”</strong>。</p>
  </li>
  <li>
    <p>在边栏选项卡顶部，单击 <strong>“保存”</strong>。</p>
  </li>
  <li>
    <p>导航回 Azure 仪表板。</p>
  </li>
</ol>

<h4 id="任务-2从-iot-中心取消注册设备">任务 2：从 IoT 中心取消注册设备</h4>

<ol>
  <li>
    <p>在“资源”磁贴中，单击 <strong>“iot-az220-training-{your-id}”</strong>。</p>
  </li>
  <li>
    <p>在 IoT 中心边栏选项卡左侧菜单中的 <strong>“浏览器”</strong> 下，单击 <strong>“IoT 设备”</strong>。</p>
  </li>
  <li>
    <p>在 <strong>“IoT 设备”</strong> 窗格的 <strong>“设备 ID”</strong> 下，找到 <strong>“sensor-th-2004”</strong> 设备。</p>
  </li>
  <li>
    <p>单击 <strong>sensor-thl-2004</strong> 左侧的复选框。</p>
  </li>
  <li>
    <p>在 <strong>“IoT 设备”</strong> 窗格顶部，单击 <strong>“删除”</strong>，然后单击 <strong>“是”</strong>。</p>
  </li>
</ol>

<h4 id="任务-3确认设备已取消预配">任务 3：确认设备已取消预配</h4>

<ol>
  <li>
    <p>切换到包含 ContainerDevice2004 代码项目的“Visual Studio Code”窗口。</p>

    <p>如果在上一练习后关闭了 Visual Studio Code，请使用 Visual Studio Code 打开 ContainerDevice2004 文件夹。</p>
  </li>
  <li>
    <p>在 <strong>“查看”</strong> 菜单中，单击 <strong>“终端”</strong>。</p>
  </li>
  <li>
    <p>确保命令提示符位于 <strong>“ContainerDevice2004”</strong> 文件夹位置。</p>
  </li>
  <li>
    <p>要开始运行模拟设备应用，请输入以下命令：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">code</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock41" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock41" class="mt-0"><code class="language-cmd/sh"> dotnet run
</code></pre>
  </li>
  <li>
    <p>请注意设备尝试预配时列出的例外情况。</p>

    <p>当设备尝试连接设备预配服务并对其进行身份验证，该服务会首先查找与设备凭据匹配的单独注册。然后，服务搜索登记组以确定是否可以预配设备。如果该服务发现设备具有已禁用的单个注册，它将阻止设备进行连接。即使设备的证书链中存在针对中间或根 CA 的已启用的注册组，服务也会阻止连接。</p>

    <p>当应用程序尝试使用配置的 X.509 证书连接 DPS 时，DPS 会报告“DeviceRegistrationResult.Status 不是‘已分配’”。</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">code</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock42" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock42" class="mt-0"><code class="language-txt"> Found certificate: 13F32448E03F451E897B681758BAC593A60BFBFA CN=sensor-thl-2004; PrivateKey: True
 Using certificate 13F32448E03F451E897B681758BAC593A60BFBFA CN=sensor-thl-2004
 ProvisioningClient AssignedHub: ; DeviceID:
 Unhandled exception. System.Exception: DeviceRegistrationResult.Status is NOT 'Assigned'
 at ContainerDevice.Program.ProvisionDevice(ProvisioningDeviceClient provisioningDeviceClient, SecurityProviderX509Certificate security) in C:\Users\howdc\Allfiles\Labs\06-Automatic Enrollment of Devices
 in DPS\Starter\ContainerDevice2004\Program.cs:line 107
 at ContainerDevice.Program.Main(String[] args) in C:\Users\howdc\Allfiles\Labs\06-Automatic Enrollment of Devices in DPS\Starter\ContainerDevice2004\Program.cs:line 49
 at ContainerDevice.Program.&lt;Main&gt;(String[] args)
</code></pre>

    <p>如果返回 Azure 门户，启用或删除单独注册，设备可以再次向 DPS 进行身份验证并连接到 IoT 中心。如果删除单独注册，会将设备自动添加回组注册。</p>
  </li>
</ol>

<h3 id="练习-6取消预配组注册">练习 6：取消预配组注册</h3>

<p>在本练习中，将取消预配整个注册组。同样，这包括从设备预配服务中取消注册以及从 IoT 中心取消设备注册。</p>

<h4 id="任务-1从-dps-中取消注册组的注册">任务 1：从 DPS 中取消注册组的注册</h4>

<p>在此任务中，将删除注册组，这也会删除注册的设备。</p>

<ol>
  <li>
    <p>导航到 Azure 仪表板。</p>
  </li>
  <li>
    <p>在“资源”磁贴上，单击 <strong>“dps-az220-training-{your-id}”</strong>。</p>
  </li>
  <li>
    <p>在 DPS 边栏选项卡左侧菜单中的 <strong>“设置”</strong> 下，单击 <strong>“管理注册”</strong>。</p>
  </li>
  <li>
    <p>在 <strong>“注册组”</strong> 列表中的 <strong>“组名”</strong> 下，单击 <strong>“eg-test-simulated-devices”</strong>。</p>
  </li>
  <li>
    <p>在 <strong>“注册组详细信息”</strong> 边栏选项卡上，向下滚动以找到 <strong>“启用输入”</strong> 字段，然后单击 <strong>“禁用”</strong>。</p>

    <p>禁用 DPS 中的组注册可以使你暂时禁用此注册组中的设备。这提供了这些设备不应使用的 X.509 证书的临时列表。</p>
  </li>
  <li>
    <p>在边栏选项卡顶部，单击 <strong>“保存”</strong>。</p>

    <p>如果您现在运行一个模拟设备，您将看到一条错误消息，与您在禁用的个人注册中看到的类似。</p>

    <p>要永久删除注册组，必须从 DPS 删除注册组。</p>
  </li>
  <li>
    <p>在 <strong>“管理注册”</strong> 窗格的 <strong>“组名称”</strong> 下，选中 <strong>“eg-test-simulated-devices”</strong> 左侧的复选框。</p>

    <p>如果已选中 <strong>“simulated-devices”</strong> 左侧的复选框，请将其保持为选中状态。</p>
  </li>
  <li>
    <p>在顶部 <strong>“管理注册”</strong> 窗格中，单击 <strong>“删除”</strong>。</p>
  </li>
  <li>
    <p>当系统提示你确认 <strong>“删除注册”</strong> 操作时，请单击 <strong>“是”</strong> 。</p>

    <p>删除后，组注册将从 DPS 中完全删除，需要重新创建才能将其添加回 DPS。</p>

    <blockquote>
      <p><strong>备注：</strong>  如果删除证书的注册组，根证书或其证书链中更高位置的另一个中间证书仍然存在另一个已启用的注册组，则在其证书链中包含该证书的设备可能仍然可以注册。</p>
    </blockquote>
  </li>
  <li>
    <p>返回 Azure 门户仪表板。</p>
  </li>
</ol>

<h4 id="任务-2从-iot-中心取消注册设备-1">任务 2：从 IoT 中心取消注册设备</h4>

<p>将注册组从设备预配服务 (DPS) 中删除后，设备注册仍存在于 Azure IoT 中心内。若要完全取消注册设备，还需要删除该注册。</p>

<ol>
  <li>
    <p>在“资源”磁贴上，单击 <strong>“iot-az220-training-{your-id}”</strong>。</p>
  </li>
  <li>
    <p>在“IoT 中心”边栏选项卡左侧菜单中的 <strong>“资源管理器”</strong> 下，单击 <strong>“IoT 设备”</strong>。</p>
  </li>
  <li>
    <p>请注意，Azure IoT 中心设备注册表中仍有 <strong>sensor-thl-2000</strong> 和其他组注册设备的设备 ID。</p>
  </li>
  <li>
    <p>若要删除 sensor-thl-2000 设备，请选中 <strong>“sensor-thl-2000”</strong> 左侧的复选框，然后单击 <strong>“删除”</strong>。</p>
  </li>
  <li>
    <p>当出现提示“ <em>是否确定要删除选定设备</em>”时，单击 <strong>“是的”</strong>。</p>
  </li>
  <li>
    <p>重复上述步骤 4-5 以删除以下设备：</p>

    <ul>
      <li>sensor-thl-2001</li>
      <li>sensor-thl-2002</li>
      <li>sensor-thl-2003</li>
    </ul>
  </li>
</ol>

<h4 id="任务-3确认设备已取消预配-1">任务 3：确认设备已取消预配</h4>

<p>从“设备预配服务”中删除组注册，并从“Azure IoT 中心”设备注册表中删除设备后，该设备便从解决方案中完全删除。</p>

<ol>
  <li>
    <p>切换到包含 ContainerDevice 代码项目的“Visual Studio Code”窗口。</p>

    <p>如果在上一练习后关闭了 Visual Studio Code，请使用 Visual Studio Code 打开实验室 6 启动程序文件夹。</p>
  </li>
  <li>
    <p>在 Visual Studio Code 的 <strong>“视图”</strong> 菜单上，单击 <strong>“终端”</strong>。</p>
  </li>
  <li>
    <p>确保命令提示符位于 <strong>“ContainerDevice”</strong> 文件夹位置。</p>
  </li>
  <li>
    <p>要开始运行模拟设备应用，请输入以下命令：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">code</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock43" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock43" class="mt-0"><code class="language-cmd/sh"> dotnet run
</code></pre>
  </li>
  <li>
    <p>请注意设备尝试预配时列出的例外情况。</p>

    <p>既然组注册和已注册设备已被删除，模拟设备将不能再预配或连接。当应用程序尝试使用配置的 X.509 证书连接到 DPS 时，它将返回 <code>ProvisioningTransportException</code> 错误消息。</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">code</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock44" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock44" class="mt-0"><code class="language-txt"> Found certificate: AFF851ED016CA5AEB71E5749BCBE3415F8CF4F37 CN=sensor-thl-2000; PrivateKey: True
 Using certificate AFF851ED016CA5AEB71E5749BCBE3415F8CF4F37 CN=sensor-thl-2000
 RegistrationID = sensor-thl-2000
 ProvisioningClient RegisterAsync . . . Unhandled exception. Microsoft.Azure.Devices.Provisioning.Client.ProvisioningTransportException: {"errorCode":401002,"trackingId":"df969401-c766-49a4-bab7-e769cd3cb585","message":"Unauthorized","timestampUtc":"2019-12-20T21:30:46.6730046Z"}
    at Microsoft.Azure.Devices.Provisioning.Client.Transport.ProvisioningTransportHandlerAmqp.ValidateOutcome(Outcome outcome)
    at Microsoft.Azure.Devices.Provisioning.Client.Transport.ProvisioningTransportHandlerAmqp.RegisterDeviceAsync(AmqpClientConnection client, String correlationId, DeviceRegistration deviceRegistration)
    at Microsoft.Azure.Devices.Provisioning.Client.Transport.ProvisioningTransportHandlerAmqp.RegisterAsync(ProvisioningTransportRegisterMessage message, CancellationToken cancellationToken)
</code></pre>
  </li>
</ol>

<p>你已针对设备预配服务完成了 IoT 设备生命周期中的注册、配置和取消预配。</p>

            </article>
        </main>
    </div>
    <footer class="fixed-bottom d-print-none">
        <nav class="navbar navbar-light bg-light d-flex justify-content-around">
            <span class="navbar-text">
                <i class="fa fa-github" aria-hidden="true"></i>
                <a href="https://github.com/MicrosoftLearning/AZ-220ZH-Microsoft-Azure-IoT-Developer" target="_blank" class="ml-2">
                    MicrosoftLearning/AZ-220ZH-Microsoft-Azure-IoT-Developer
                </a>
            </span>
        </nav>
    </footer>
    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script src="../../assets/js/script_v%3D653337691cd169b6aa5719d4ea66f4e6a878a19c.js"></script>



</body></html>