<!DOCTYPE html><html lang="en"><head>
        <title>
            AZ-220ZH-Microsoft-Azure-IoT-Developer
        </title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" crossorigin="anonymous">
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" crossorigin="anonymous">
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/vs.min.css">
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        <link rel="stylesheet" href="../../assets/css/style_v%3D653337691cd169b6aa5719d4ea66f4e6a878a19c.css">
    </head>
    <body data-spy="scroll" data-target="#linksMenu">
    <nav class="navbar navbar-expand-lg navbar-dark bg-black">
        <div class="container d-flex justify-content-between">
            <a class="my-1 title text-azure text-uppercase" href="../../">
                AZ-220ZH-Microsoft-Azure-IoT-Developer
            </a>
            <a href="https://github.com/MicrosoftLearning/AZ-220ZH-Microsoft-Azure-IoT-Developer" target="_blank" class="btn btn-sm btn-outline-secondary text-light">
                <i class="fa fa-github" aria-hidden="true"></i>
                <span class="ml-2">GitHub</span>
            </a>
        </div>
    </nav>
    <div class="container">
        <main class="row extra-padding">
            <aside class="col-sm-2">       
                <nav id="linksMenu" class="toc sticky-top">
                    <ul class="nav navbar-nav flex-column">
                    <li class="nav-item"><a class="nav-link" href="#简化的实验室条件">简化的实验室条件</a></li><li class="nav-item"><a class="nav-link active" href="#练习-1验证实验室先决条件">练习 1：验证实验室先决条件</a></li><li class="nav-item"><a class="nav-link" href="#练习-2写入发送和接收遥测的代码">练习 2：写入发送和接收遥测的代码</a></li><li class="nav-item"><a class="nav-link" href="#练习-3创建第二个应用以接收遥测">练习 3：创建第二个应用以接收遥测</a></li><li class="nav-item"><a class="nav-link" href="#练习-4编写代码以调用直接方法">练习 4：编写代码以调用直接方法</a></li><li class="nav-item"><a class="nav-link" href="#练习-5实现设备孪生功能">练习 5：实现设备孪生功能</a></li></ul>
                </nav>         
            </aside>
            <hr class>
            <article class="col-sm-10 mb-5">
                <h1 id="使用-azure-iot-中心远程监视和控制设备">使用 Azure IoT 中心远程监视和控制设备</h1>

<h2 id="实验室场景">实验室场景</h2>

<p>Contoso 为其屡获殊荣的奶酪产品感到自豪，并在整个制造过程中都保持最佳的温度和湿度，但老化过程中的条件始终受到特别关注。</p>

<p>近年来，Contoso 使用环境传感器来记录其天然奶酪储藏室中发生老化的条件，并使用该数据来识别接近完美的环境。来自最成功（也称为获奖产品）位置的数据表明，老化奶酪的理想温度约为 50 华氏度 +/- 5 度（10 摄氏度 +/- 2.8 度）。以最大饱和度的百分比衡量的理想湿度值约为 85% +/- 10%。</p>

<p>这些理想的温度和湿度值适用于大多数类型的奶酪。但是，对于特别坚硬或特别软的奶酪，需要做出较小的调整。还必须在老化过程中的关键时间/阶段调整环境条件，以实现特定的结果，例如奶酪皮的理想条件。</p>

<p>Contoso 非常幸运，可以经营奶酪储藏室（在某些地理区域内），这些奶酪储藏室几乎全年都可以自然保持理想的条件。但是，即使在这些位置，老化过程中的环境管理也至关重要。同样，天然储藏室通常具有许多不同的洞室，每个洞室的环境可能略有不同。各种奶酪放置在符合其特定要求的洞室（区域）中。为了将环境条件保持在期望的限制内，Contoso 使用了同时控制温度和湿度的空气处理/调节系统。</p>

<p>当前，操作员监视储藏室设施每个区域内的环境条件，并在需要保持所需温度和湿度时调整空气处理系统设置。操作员能够每隔 4 小时访问每个区域并检查环境条件。在白天高温和夜间低温之间温度急剧变化的地方，条件可能会超出所需的限制。</p>

<p>Contoso 已责成你实现自动化系统，以使储藏室环境保持在控制范围内。</p>

<p>在本实验室中，你将为实现  IoT 设备的奶酪储藏室监控系统进行原型设计。每个设备都配备了温度和湿度传感器，并连接到空气处理系统，该系统控制设备所在区域的温度和湿度。</p>

<h3 id="简化的实验室条件">简化的实验室条件</h3>

<p>遥测输出的频率是生产解决方案中的重要考虑因素。制冷单元中的温度传感器可能只需要每分钟报告一次，而飞机上的加速度传感器可能需要每秒报告十次。在某些情况下，必须发送遥测的频率取决于当前条件。例如，如果我们的奶酪储藏室环境温度总是在夜间快速下降，日落前两小时会开始更频繁地进行传感器读数。当然，更改遥测频率的要求不需要是可预测模式的一部分，让我们更改 IoT 设备设置的事件可能是不可预测的。</p>

<p>为了保持在本实验室的简单易行，我们将做出以下假设：</p>

<ul>
  <li>设备将每隔几秒向 IoT 中心发送遥测数据（温度和湿度值）。虽然这种频率对于奶酪储藏室来说是不现实的，但当我们需要经常看到变化时，而不是每 15 分钟一次，它对于实验室环境来说非常重要。</li>
  <li>空气处理系统是一个风扇，可以处于以下三种状态之一：开、关或失败。
    <ul>
      <li>风扇初始化为“关闭”状态。</li>
      <li>使用 IoT 设备上的直接方法来控制（打开/关闭）风扇的电源。</li>
      <li>设备孪生所需属性值用于设置风扇的所需状态。所需属性值将覆盖风扇/设备的任何默认设置。</li>
      <li>可以通过打开/关闭风扇来控制温度（打开风扇会降低温度）</li>
    </ul>
  </li>
</ul>

<p>本实验中的编码分为三个部分：发送和接收遥测，调用和运行直接方法，设置和读取设备孪生属性。</p>

<p>你将首先编写两个应用：一个用于发送遥测的设备，另一个用于后端服务（将在云中运行）以接收遥测。</p>

<p>将创建以下资源：</p>

<p><a href="media/LAB_AK_15-architecture.png" target="_blank"><img src="media/LAB_AK_15-architecture.png" alt="实验室 15 基础结构"></a></p>

<h2 id="本实验室概览">本实验室概览</h2>

<p>在本实验室中，你将完成以下活动：</p>

<ul>
  <li>
    <p>验证是否满足实验室先决条件（具有必需的 Azure 资源）</p>

    <ul>
      <li>该脚本将创建 IoT 中心（如果需要）。</li>
      <li>该脚本将创建本实验室所需的新设备标识。</li>
    </ul>
  </li>
  <li>创建模拟设备应用以将设备遥测发送到 IoT 中心</li>
  <li>创建后端服务应用以侦听遥测数据</li>
  <li>实现直接方法，以将设置传达给 IoT 设备</li>
  <li>实现设备孪生功能，以管理 IoT 设备属性</li>
</ul>

<h2 id="实验室说明">实验室说明</h2>

<h3 id="练习-1验证实验室先决条件">练习 1：验证实验室先决条件</h3>

<p>本实验室假定以下 Azure 资源可用：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">资源类型</th>
      <th style="text-align: left">资源名称</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">资源组</td>
      <td style="text-align: left">rg-az220</td>
    </tr>
    <tr>
      <td style="text-align: left">IoT 中心</td>
      <td style="text-align: left">iot-az220-training-{your-id}</td>
    </tr>
    <tr>
      <td style="text-align: left">IoT 设备</td>
      <td style="text-align: left">sensor-th-0055</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p><strong>重要说明</strong>： 运行设置脚本以创建所需设备。</p>
</blockquote>

<p>若要创建任何缺少的资源和新设备，在开始练习 2 之前，需要先按照下面的说明运行 <strong>lab15-setup.azcli</strong> 脚本。脚本文件包含在本地克隆作为开发环境配置（实验室 3）的 GitHub 存储库中。</p>

<p>写入 <strong>lab15-setup.azcli</strong> 脚本，并在 <strong>Bash</strong> shell 环境中运行，执行此操作最简便的方法是在 Azure Cloud Shell 中。</p>

<blockquote>
  <p><strong>备注：</strong> 你将需要 <strong>“sensor-th-0055”</strong> 设备的连接字符串。如果你已经在 Azure IoT 中心注册了此设备，则可以通过在 Azure Cloud Shell 中运行以下命令来获取连接字符串</p>

  <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">code</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock0" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock0" class="mt-0"><code class="language-bash hljs">az iot hub device-identity connection-string show --hub-name iot-az220-training-{your-id} --device-id sensor-th-0055 -o tsv
</code></pre>
</blockquote>

<ol>
  <li>
    <p>使用浏览器，打开 <a href="https://shell.azure.com/">Azure Cloud Shell</a>，并使用本课程使用的 Azure 订阅登录。</p>

    <p>如果系统提示设置 Cloud Shell 的存储，请接受默认设置。</p>
  </li>
  <li>
    <p>验证 Cloud Shell 是否在使用 <strong>Bash</strong>。</p>

    <p>Azure Cloud Shell 页面左上角的下拉菜单用于选择环境。验证所选的下拉值是否为 <strong>Bash</strong>。</p>
  </li>
  <li>
    <p>在 Cloud Shell 工具栏上，单击 <strong>“上传/下载文件”</strong> （从右数第四个按钮）。</p>
  </li>
  <li>
    <p>在下拉菜单中，单击 <strong>“上传”</strong>。</p>
  </li>
  <li>
    <p>在“文件选择”对话框中，导航到配置开发环境时下载的 GitHub 实验室文件的文件夹位置。</p>

    <p>在“实验室 3：<em>设置开发环境</em>，你可以通过下载 ZIP 文件并从本地提取内容来克隆包含实验室资源的 GitHub 存储库。提取的文件夹结构包括以下文件夹路径：</p>

    <ul>
      <li>Allfiles
        <ul>
          <li>实验室
            <ul>
              <li>15-使用 Azure IoT 中心远程监视和控制设备
                <ul>
                  <li>设置</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>

    <p>lab15-setup.azcli 脚本文件位于实验室 15 的 Setup 文件夹中。</p>
  </li>
  <li>
    <p>选择 <strong>“lab15-setup.azcli”</strong> 文件，然后单击 <strong>“打开”</strong>。</p>

    <p>文件上传完成后，系统将显示一条通知。</p>
  </li>
  <li>
    <p>若要验证在 Azure Cloud Shell 中已上传了正确文件，请输入以下命令：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">code</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock1" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock1" class="mt-0"><code class="language-bash hljs"> ls
</code></pre>

    <p>使用 <code>ls</code> 命令列出当前目录的内容。你应该会看到列出的 lab15-setup.azcli 文件。</p>
  </li>
  <li>
    <p>若要为此实验室创建一个包含安装脚本的目录，然后移至该目录，请输入以下 Bash 命令：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">code</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock2" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock2" class="mt-0"><code class="language-bash hljs"> mkdir lab15
 mv lab15-setup.azcli lab15
 <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> lab15
</code></pre>
  </li>
  <li>
    <p>为了保证 <strong>lab15-setup.azcli</strong> 具有执行权限，请输入以下命令：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">code</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock3" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock3" class="mt-0"><code class="language-bash hljs"> chmod +x lab15-setup.azcli
</code></pre>
  </li>
  <li>
    <p>在 Cloud Shell 工具栏上，请单击 <strong>“打开编辑器”</strong> （右侧的第二个按钮 - <strong>{ }</strong>）以启用对 lab15-setup.azcli 文件的访问。</p>
  </li>
  <li>
    <p>在 <strong>“文件存储”</strong> 列表中，展开 lab15 文件夹并打开脚本文件，单击 <strong>“lab15”</strong>，然后单击 <strong>“lab15-setup.azcli”</strong>。</p>

    <p>编辑器现在将显示 <strong>lab15-setup.azcli</strong> 文件的内容。</p>
  </li>
  <li>
    <p>在编辑器中，更新 <code>{your-id}</code> 和 <code>{your-location}</code> 分配的值。</p>

    <p>以下面的示例为例，需要将 <code>{your-id}</code> 设置为在本课程开始时创建的唯一 ID（即 <strong>cah191211</strong>），然后将 <code>{your-location}</code> 设置为对你的资源有意义的位置。</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">code</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock4" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock4" class="mt-0"><code class="language-bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#!/bin/bash</span></span>

 <span class="hljs-comment"><span class="hljs-comment"># 更改这些值！</span></span>
 YourID=<span class="hljs-string"><span class="hljs-string">"{your-id}"</span></span>
 Location=<span class="hljs-string"><span class="hljs-string">"{your-location}"</span></span>
</code></pre>

    <blockquote>
      <p><strong>备注：</strong>  应将 <code>{your-location}</code> 变量设置为要部署所有资源的区域的短名称。输入以下命令，可以看到可用位置及其短名称的列表（<strong>“名称”</strong> 列）：</p>
    </blockquote>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">code</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock5" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock5" class="mt-0"><code class="language-bash hljs"> az account list-locations -o Table

 DisplayName           Latitude    Longitude    Name
 --------------------  ----------  -----------  ------------------
 East Asia             22.267      114.188      eastasia
 Southeast Asia        1.283       103.833      southeastasia
 Central US            41.5908     -93.6208     centralus
 East US               37.3719     -79.8164     eastus
 East US 2             36.6681     -78.3889     eastus2
</code></pre>
  </li>
  <li>
    <p>要保存对文件所做的更改并关闭编辑器，请单击编辑器窗口右上角的 “<strong>…</strong>”，然后单击 <strong>“关闭编辑器”</strong>。</p>

    <p>如果提示保存，请单击 <strong>“保存”</strong>，编辑器将会关闭。</p>

    <blockquote>
      <p><strong>备注：</strong> 可以使用 <strong>Ctrl+S</strong> 随时保存，使用 <strong>Ctrl+Q</strong> 关闭编辑器。</p>
    </blockquote>
  </li>
  <li>
    <p>要创建本实验室所需的资源，请输入以下命令：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">code</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock6" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock6" class="mt-0"><code class="language-bash hljs"> ./lab15-setup.azcli
</code></pre>

    <p>运行此脚本可能需要几分钟。每个步骤完成时，你都会看到输出。</p>

    <p>该脚本将首先创建一个名为 <strong>rg-az220</strong> 的资源组和一个名为 <strong>iot-az220-training-{your-id}</strong> 的 IoT 中心。如果它们已经存在，将显示相应的消息。然后，脚本会将 ID 为 <strong>“sensor-th-0055”</strong> 的设备添加到 IoT 中心并显示设备连接字符串。</p>
  </li>
  <li>
    <p>请注意，脚本完成后，将显示与你的 IoT 中心和设备有关的信息。</p>

    <p>脚本将显示类似于以下内容的信息：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">code</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock7" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock7" class="mt-0"><code class="language-text"> Configuration Data:
 ------------------------------------------------
 iot-az220-training-{your-id} Service connectionstring:
 HostName=iot-az220-training-{your-id}.azure-devices.net;SharedAccessKeyName=iothubowner;SharedAccessKey=nV9WdF3Xk0jYY2Da/pz2i63/3lSeu9tkW831J4aKV2o=

 sensor-th-0055 device connection string:
 HostName=iot-az220-training-{your-id}.azure-devices.net;DeviceId=sensor-th-0055;SharedAccessKey=TzAzgTYbEkLW4nWo51jtgvlKK7CUaAV+YBrc0qj9rD8=

 iot-az220-training-{your-id} eventhub endpoint:
 sb://iothub-ns-iot-az220-training-2610348-5a463f1b56.servicebus.windows.net/

 iot-az220-training-{your-id} eventhub path:
 iot-az220-training-{your-id}

 iot-az220-training-{your-id} eventhub SaS primarykey:
 tGEwDqI+kWoZroH6lKuIFOI7XqyetQHf7xmoSf1t+zQ=
</code></pre>
  </li>
  <li>
    <p>将脚本显示的输出复制到文本文档中，以供本实验室稍后使用。</p>

    <p>将信息保存到可以轻松找到的位置后，就可以继续进行本实验。</p>
  </li>
</ol>

<h3 id="练习-2写入发送和接收遥测的代码">练习 2：写入发送和接收遥测的代码</h3>

<p>在本练习中，你将创建模拟设备应用（适用于 sensor-th-0055 设备），该应用将遥测发送到 IoT 中心。</p>

<h4 id="任务-1打开生成遥测的模拟设备">任务 1：打开生成遥测的模拟设备</h4>

<ol>
  <li>
    <p>打开 <strong>Visual Studio Code</strong>。</p>
  </li>
  <li>
    <p>在 <strong>“文件”</strong> 菜单上，单击 <strong>“打开文件夹”</strong></p>
  </li>
  <li>
    <p>在“打开文件夹”对话框中，导航到实验室 15 的 Starter 文件夹。</p>

    <p>在“实验室 3：<em>设置开发环境</em>，你可以通过下载 ZIP 文件并从本地提取内容来克隆包含实验室资源的 GitHub 存储库。提取的文件夹结构包括以下文件夹路径：</p>

    <ul>
      <li>Allfiles
        <ul>
          <li>实验室
            <ul>
              <li>15-使用 Azure IoT 中心远程监视和控制设备
                <ul>
                  <li>入门
                    <ul>
                      <li>cheesecavedevice</li>
                      <li>CheeseCaveOperator</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>单击 <strong>“cheesecavedevice”</strong>，然后单击 <strong>“选择文件夹”</strong>。</p>

    <p>你应该会在 Visual Studio Code 的资源管理器窗格中看到以下文件：</p>

    <ul>
      <li>cheesecavedevice.csproj</li>
      <li>Program.cs</li>
    </ul>
  </li>
  <li>
    <p>若要打开代码文件，请单击 <strong>“Program.cs”</strong>。</p>

    <p>粗略地看上一眼即可发现，此应用程序与你在之前的实验中使用过的模拟设备应用程序非常相似。此版本使用对称密钥身份验证，将遥测和日志记录消息发送到 IoT 中心，并且具有更复杂的传感器实现。</p>
  </li>
  <li>
    <p>在 <strong>“终端”</strong> 菜单中，单击 <strong>“新建终端”</strong>。</p>

    <p>注意命令提示符中指示的目录路径。你无需在上一个实验室项目的文件夹结构中开始构建此项目。</p>
  </li>
  <li>
    <p>在终端命令提示符下，请输入以下命令以验证应用程序版本：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">code</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock8" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock8" class="mt-0"><code class="language-bash hljs"> dotnet build
</code></pre>

    <p>输出结果会类似于：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">code</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock9" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock9" class="mt-0"><code class="language-text"> &gt; dotnet build
 Microsoft (R) Build Engine version 16.5.0+d4cbfca49 for .NET Core
 Copyright (C) Microsoft Corporation. All rights reserved.

 Restore completed in 39.27 ms for D:\Az220-Code\AllFiles\Labs\15-Remotely monitor and control devices with Azure IoT Hub\Starter\CheeseCaveDevice\CheeseCaveDevice.csproj.
 CheeseCaveDevice -&gt; D:\Az220-Code\AllFiles\Labs\15-Remotely monitor and control devices with Azure IoT Hub\Starter\CheeseCaveDevice\bin\Debug\netcoreapp3.1\CheeseCaveDevice.dll

 Build succeeded.
     0 Warning(s)
     0 Error(s)

 Time Elapsed 00:00:01.16
</code></pre>
  </li>
</ol>

<p>在下一个任务中，你将配置连接字符串并查看应用程序。</p>

<h4 id="任务-2配置连接并查看代码">任务 2：配置连接并查看代码</h4>

<p>你在此任务中构建的模拟设备应用将模拟监视温度和湿度的 IoT 设备。该应用将模拟传感器读数并每两秒钟传达一次传感器数据。</p>

<ol>
  <li>
    <p>在 <strong>Visual Studio Code</strong> 中，确保已打开 Program.cs 文件。</p>
  </li>
  <li>
    <p>在代码编辑器中，找到以下代码行：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">c#</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock10" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock10" class="mt-0"><code class="language-csharp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> deviceConnectionString = <span class="hljs-string"><span class="hljs-string">"&lt;your device connection string&gt;"</span></span>;
</code></pre>
  </li>
  <li>
    <p>将 <strong>“&lt;your device connection string&gt;”</strong> 替换为你之前保存的设备连接字符串。</p>

    <p>这是在将遥测发送到 IoT 中心之前唯一需要实现的更改。</p>
  </li>
  <li>
    <p>在 <strong>“文件”</strong> 菜单中，单击 <strong>“保存”</strong>。</p>
  </li>
  <li>
    <p>花点时间查看一下应用程序的结构。</p>

    <p>请注意，该应用程序的结构与之前的实验室中使用的应用程序类似：</p>

    <ul>
      <li>使用语句</li>
      <li>命名空间定义
        <ul>
          <li>Program 类 - 负责连接到 Azure IoT 并发送遥测</li>
          <li>CheeseCaveSimulator 类 -（代替 EnvironmentSensor）而不仅仅是生成遥测，该类还模拟了一个运行中的奶酪储藏室环境，该环境受冷却风扇运行的影响。</li>
          <li>ConsoleHelper - 将编写不同彩色文本封装到控制台的类</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>查看 <strong>Main</strong> 方法：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">c#</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock11" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock11" class="mt-0"><code class="language-csharp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)
 </span></span>{
     ConsoleHelper.WriteColorMessage(<span class="hljs-string"><span class="hljs-string">"Cheese Cave device app.\n"</span></span>, ConsoleColor.Yellow);

     <span class="hljs-comment"><span class="hljs-comment">// 使用 MQTT 协议连接到 IoT 中心。</span></span>
     deviceClient = DeviceClient.CreateFromConnectionString(deviceConnectionString, TransportType.Mqtt);

     <span class="hljs-comment"><span class="hljs-comment">// 创建奶酪储藏室模拟器实例</span></span>
     cheeseCave = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CheeseCaveSimulator();

     <span class="hljs-comment"><span class="hljs-comment">// 在下方插入注册直接方法编码</span></span>

     <span class="hljs-comment"><span class="hljs-comment">// 在下方插入注册所需属性更改处理程序代码</span></span>

     SendDeviceToCloudMessagesAsync();
     Console.ReadLine();
 }
</code></pre>

    <p>与前面的实验室中一样，<strong>Main</strong> 方法用于建立与 IoT 中心的连接。你可能已经注意到，它将用于与设备孪生属性更改集成，在本例中，还将集成直接方法。</p>
  </li>
  <li>
    <p>简要查看一下 <strong>SendDeviceToCloudMessagesAsync</strong> 方法。</p>

    <p>请注意，它与你在之前的实验中创建的先前版本非常相似。</p>
  </li>
  <li>
    <p>看看 <strong>CheeseCaveSimulator</strong> 类。</p>

    <p>它由在之前的实验室中使用的 <strong>EnvironmentSensor</strong> 类演变而来。主要差异在于引入风扇 - 如果风扇处于 <strong>“开启”</strong> 状态，则温度和湿度将逐渐达到所需值，而如果风扇处于 <strong>“关闭”</strong> （或 <strong>“故障”</strong>）状态，则温度和湿度将逐渐靠近环境值。值得注意的是，在读取温度时，有 1% 可能性将风扇设置为 <strong>“故障”</strong> 状态。</p>
  </li>
</ol>

<h4 id="任务-3测试你的代码以发送遥测">任务 3：测试你的代码以发送遥测</h4>

<ol>
  <li>
    <p>在 Visual Studio Code 中，确保“终端”仍处于打开状态。</p>
  </li>
  <li>
    <p>在终端命令提示符下，输入以下命令以运行模拟设备应用：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">code</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock12" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock12" class="mt-0"><code class="language-bash hljs"> dotnet run
</code></pre>

    <p>此命令将在当前文件夹中运行 <strong>“Program.cs”</strong> 文件。</p>
  </li>
  <li>
    <p>注意输出已发送到终端。</p>

    <p>你应该很快就能看到控制台输出，类似于：</p>

    <p><a href="media/LAB_AK_15-cheesecave-telemetry.png" target="_blank"><img src="media/LAB_AK_15-cheesecave-telemetry.png" alt="控制台输出"></a></p>

    <blockquote>
      <p><strong>备注：</strong>  绿色文本表示一切正常。红色文本表示存在异常。如果你看到的屏幕与上图并不相似，请首先检查设备连接字符串。</p>
    </blockquote>
  </li>
  <li>
    <p>保持此应用持续运行。</p>

    <p>在本实验的后部分，你需要将遥测发送到 IoT 中心。</p>
  </li>
</ol>

<h3 id="练习-3创建第二个应用以接收遥测">练习 3：创建第二个应用以接收遥测</h3>

<p>现在，你已有将遥测发送到 IoT 中心的（模拟）奶酪储藏室设备，你需要创建一个后端应用，该应用可以连接到 IoT 中心并“侦听”该遥测。最终，此后端应用将用于自动控制奶酪储藏室中的温度。</p>

<h4 id="任务-1创建一个应用以接收遥测">任务 1：创建一个应用以接收遥测</h4>

<p>在此任务中，你将开始使用后端应用，该应用用于从 IoT 中心事件中心终结点接收遥测。</p>

<ol>
  <li>
    <p>打开一个新的 Visual Studio Code 实例。</p>

    <p>由于模拟设备应用正在已打开的 Visual Studio Code 窗口中运行，因此你需要为后端应用提供一个新的 Visual Studio Code 实例。</p>
  </li>
  <li>
    <p>在 <strong>“文件”</strong> 菜单上，单击 <strong>“打开文件夹”</strong></p>
  </li>
  <li>
    <p>在 <strong>“打开文件夹”</strong> 对话框中，导航到实验室 15 的 Starter 文件夹。</p>
  </li>
  <li>
    <p>单击 <strong>“CheeseCaveOperator”</strong>，然后单击 <strong>“选择文件夹”</strong>。</p>

    <p>事先已准备好的 CheeseCaveOperator 应用程序是一个简单的控制台应用程序，其中包括几个 NuGet 包库和一些用于指导你完成构建代码的过程的注释。你需要先向项目添加代码块，然后才能运行应用程序。</p>
  </li>
  <li>
    <p>在 <strong>“资源管理器”</strong> 窗格中，单击 <strong>“CheeseCaveOperator.csproj”</strong> 打开应用程序项目文件。</p>

    <p>现在，<strong>CheeseCaveOperator.csproj</strong> 文件应该在代码编辑器窗格中打开。</p>
  </li>
  <li>
    <p>花点时间查看 <strong>“CaveDevice.csproj”</strong> 文件的内容。</p>

    <p>文件内容应如下所示：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">xml</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock13" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock13" class="mt-0"><code class="language-xml hljs"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Project</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Sdk</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Microsoft.NET.Sdk"</span></span></span><span class="hljs-tag">&gt;</span></span>

 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PropertyGroup</span></span></span><span class="hljs-tag">&gt;</span></span>
     <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">OutputType</span></span></span><span class="hljs-tag">&gt;</span></span>Exe<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">OutputType</span></span></span><span class="hljs-tag">&gt;</span></span>
     <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TargetFramework</span></span></span><span class="hljs-tag">&gt;</span></span>netcoreapp3.1<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TargetFramework</span></span></span><span class="hljs-tag">&gt;</span></span>
 <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PropertyGroup</span></span></span><span class="hljs-tag">&gt;</span></span>

 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ItemGroup</span></span></span><span class="hljs-tag">&gt;</span></span>
     <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PackageReference</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Include</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Microsoft.Azure.Devices"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Version</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1.*"</span></span></span><span class="hljs-tag"> /&gt;</span></span>
     <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">PackageReference</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Include</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Microsoft.Azure.EventHubs"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Version</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"4.*"</span></span></span><span class="hljs-tag"> /&gt;</span></span>
 <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ItemGroup</span></span></span><span class="hljs-tag">&gt;</span></span>

 <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Project</span></span></span><span class="hljs-tag">&gt;</span></span>
</code></pre>

    <blockquote>
      <p><strong>备注：</strong> 文件中的包版本号可以高于上面显示的版本号。</p>
    </blockquote>

    <p>项目文件 (.csproj) 是一个 XML 文档，用于指定要使用的项目的类型。在本例中，项目是一个 <strong>SDK</strong> 样式的项目。</p>

    <p>正如你所见，项目定义包含两个部分 - <strong>PropertyGroup</strong> 和 <strong>ItemGroup</strong>。</p>

    <p><strong>PropertyGroup</strong> 定义构建此项目将产生的输出的类型。在本例中，你将构建面向.NET Core 3.1 的可执行文件。</p>

    <p><strong>ItemGroup</strong> 指定应用程序所需的任何外部库。这些特定的引用适用于 NuGet 包，每个包引用都指定了包名称和版本。</p>

    <blockquote>
      <p><strong>备注：</strong> 可通过在命令提示符（例如 Visual Studio Code 终端命令提示符）处输入命令 <code>dotnet add package</code> 来手动添加 NuGet 库（例如上面的 ItemGroup 中列出的库）。输入 <code>dotnet restore</code> 命令可确保下载所有依赖项。例如，若要下载上面的库并确保在代码项目中提供这些库，可输入以下命令：</p>

      <p>dotnet add package Microsoft.Azure.EventHubs
  dotnet add package Microsoft.Azure.Devices
  dotnet restore</p>

      <p><strong>信息</strong>： 可以在<a href="https://docs.microsoft.com/zh-cn/nuget/what-is-nuget">此处</a>详细了解 NuGet。</p>
    </blockquote>
  </li>
</ol>

<h4 id="任务-3添加遥测接收方代码">任务 3：添加遥测接收方代码</h4>

<ol>
  <li>
    <p>在 <strong>“资源管理器”</strong> 窗格中，单击 <strong>“Program.cs”</strong>。</p>

    <p><strong>Program.cs</strong> 文件应如下所示：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">c#</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock14" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock14" class="mt-0"><code class="language-csharp hljs"> <span class="hljs-comment"><span class="hljs-comment">// 版权所有 (c) Microsoft。保留所有权利。</span></span>
 <span class="hljs-comment"><span class="hljs-comment">// 已获得 MIT License 颁发的许可证。有关完整的许可信息，请参阅项目根目录中的许可文件。</span></span>

 <span class="hljs-comment"><span class="hljs-comment">// 在下方插入 using 语句</span></span>

 <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">CheeseCaveOperator</span></span>
 {
     <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span>
     {
         <span class="hljs-comment"><span class="hljs-comment">// 在下方插入变量</span></span>

         <span class="hljs-comment"><span class="hljs-comment">// 在下方插入 Main 方法</span></span>

         <span class="hljs-comment"><span class="hljs-comment">// 在下方插入 ReceiveMessagesFromDeviceAsync 方法</span></span>

         <span class="hljs-comment"><span class="hljs-comment">// 在下方插入 InvokeMethod 方法</span></span>

         <span class="hljs-comment"><span class="hljs-comment">// 在下方插入设备孪生部分</span></span>
     }

     <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ConsoleHelper</span></span>
     {
         <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteColorMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text, ConsoleColor clr</span></span></span><span class="hljs-function">)
         </span></span>{
             Console.ForegroundColor = clr;
             Console.WriteLine(text);
             Console.ResetColor();
         }
         <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteGreenMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text</span></span></span><span class="hljs-function">)
         </span></span>{
             WriteColorMessage(text, ConsoleColor.Green);
         }

         <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteRedMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text</span></span></span><span class="hljs-function">)
         </span></span>{
             WriteColorMessage(text, ConsoleColor.Red);
         }
     }
 }
</code></pre>

    <p>此代码概述了操作员应用的结构。</p>
  </li>
  <li>
    <p>找到注释 <code>// 在下方插入 using 语句</code>。</p>
  </li>
  <li>
    <p>若要指定应用程序代码将使用的命名空间，请输入以下代码：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">c#</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock15" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock15" class="mt-0"><code class="language-csharp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System;
 <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading.Tasks;
 <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text;
 <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic;
 <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq;

 <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.Azure.EventHubs;
 <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.Azure.Devices;
 <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Newtonsoft.Json;
</code></pre>

    <p>请注意，除了指定 <strong>System</strong> 之外，你还声明了代码将使用的其他命名空间，例如用于编码字符串的 <strong>System.Text</strong>、用于异步任务的 <strong>System.Threading.Tasks</strong> 和用于之前添加的两个包的命名空间。</p>

    <blockquote>
      <p><strong>提示</strong>： 插入代码时，代码布局可能不理想。通过在代码编辑器窗格中右键单击，然后单击 <strong>“设置文档格式”</strong>，可以让 Visual Studio Code 为你设置文档格式。可以通过打开 <strong>“任务”</strong> 窗格（按 <strong>F1</strong>），键入 <strong>“设置文档格式”</strong>，然后按 <strong>Enter</strong> 来获得相同的结果。在 Windows 上，此任务的快捷方式是 <strong>Shift+Alt+F</strong>。</p>
    </blockquote>
  </li>
  <li>
    <p>找到注释 <code>// 在下方插入变量</code>。</p>
  </li>
  <li>
    <p>若要指定程序正在使用的变量，请输入以下代码：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">c#</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock16" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock16" class="mt-0"><code class="language-csharp hljs"> <span class="hljs-comment"><span class="hljs-comment">// 全局变量。</span></span>
 <span class="hljs-comment"><span class="hljs-comment">// 与事件中心兼容的终结点。</span></span>
 <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> eventHubsCompatibleEndpoint = <span class="hljs-string"><span class="hljs-string">"&lt;your event hub endpoint&gt;"</span></span>;

 <span class="hljs-comment"><span class="hljs-comment">// 与事件中心兼容的名称。</span></span>
 <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> eventHubsCompatiblePath = <span class="hljs-string"><span class="hljs-string">"&lt;your event hub path&gt;"</span></span>;
 <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> iotHubSasKey = <span class="hljs-string"><span class="hljs-string">"&lt;your event hub SaS key&gt;"</span></span>;
 <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> iotHubSasKeyName = <span class="hljs-string"><span class="hljs-string">"service"</span></span>;
 <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> EventHubClient eventHubClient;

 <span class="hljs-comment"><span class="hljs-comment">// 在下方插入服务客户端变量</span></span>

 <span class="hljs-comment"><span class="hljs-comment">// 在下方插入注册表管理器变量</span></span>

 <span class="hljs-comment"><span class="hljs-comment">// IoT 中心的连接字符串。</span></span>
 <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> serviceConnectionString = <span class="hljs-string"><span class="hljs-string">"&lt;your service connection string&gt;"</span></span>;

 <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> deviceId = <span class="hljs-string"><span class="hljs-string">"sensor-th-0055"</span></span>;
</code></pre>
  </li>
  <li>
    <p>花点时间检查你刚刚输入的代码（和代码注释）。</p>

    <p><strong>eventHubsCompatibleEndpoint</strong> 变量用于存储 IoT 中心面向服务的内置终结点（消息/事件）的 URI，该终结点与事件中心兼容。</p>

    <p><strong>eventHubsCompatiblePath</strong> 变量包含事件中心实体的路径。</p>

    <p><strong>iotHubSasKey</strong> 变量包含命名空间或实体的相应共享访问策略规则的密钥名称。</p>

    <p><strong>iotHubSasKeyName</strong> 变量包含命名空间或实体的相应共享访问策略规则的密钥。</p>

    <p><strong>eventHubClient</strong> 变量包含将用于从 IoT 中心接收消息的事件中心客户端实例。</p>

    <p><strong>serviceClient</strong> 变量包含将用于从应用向 IoT 中心（以及从 IoT 中心向目标设备等）发送消息的服务客户端实例。</p>

    <p><strong>serviceConnectionString</strong> 变量包含用于支持操作员应用连接到 IoT 中心的连接字符串。</p>

    <p><strong>deviceId</strong> 变量包含 <strong>CheeseCaveDevice</strong> 应用程序使用的设备 ID。</p>
  </li>
  <li>
    <p>找到用于分配服务连接字符串的代码行</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">c#</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock17" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock17" class="mt-0"><code class="language-csharp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> serviceConnectionString = <span class="hljs-string"><span class="hljs-string">"&lt;your service connection string&gt;"</span></span>;
</code></pre>
  </li>
  <li>
    <p>将 <strong>“&lt;your service connection string&gt;”</strong> 替换为你之前在本实验室中保存的 IoT 中心服务连接字符串。</p>

    <p>你应该已经保存 iothubowner 共享访问策略主要连接字符串，该字符串由你之前在练习 1 中运行的 lab15-setup.azcli 设置脚本生成。</p>

    <blockquote>
      <p><strong>备注：</strong> 你可能会好奇为什么使用 <strong>iothubowner</strong>  共享策略而不是使用<strong>服务</strong>共享策略。答案与分配给每个策略的 IoT 中心权限有关。<strong>服务</strong>策略具有 <strong>ServiceConnect</strong> 权限，通常由后端云服务使用。它具有以下权利：</p>

      <ul>
        <li>授予对面向云服务的通信和监视终结点的访问权限。</li>
        <li>授予接收设备到云消息、发送云到设备消息和检索相应传送确认的权限。</li>
        <li>授予检索文件上传的传送确认的权限。</li>
        <li>授予访问孪生以更新标记和所需属性、检索报告属性和运行查询的权限。</li>
      </ul>

      <p>在实验室的第一部分中，<strong>serviceoperator</strong> 应用程序调用直接方法来切换风扇状态，<strong>服务</strong> 策略具有足够的权限。但在实验室的后半部分，将查询设备注册表。这是通过 <strong>“RegistryManager”</strong> 类实现的。为了使用 <strong>“RegistryManager”</strong> 类查询设备注册表，用于连接到 IoT 中心的共享访问策略必须具有 <strong>“注册表读取”</strong> 权限，并授予了以下权限：</p>

      <ul>
        <li>授予对标识注册表的读取访问权限。</li>
      </ul>

      <p>由于 <strong>iothubowner</strong> 策略已被授予 <strong>“注册表写入”</strong> 权限，同时它还继承了 <strong>“注册表读取”</strong> 权限，因此它适合你的需要。</p>

      <p>在生产方案中，你可以考虑添加一个新的仅具有<strong>服务连接</strong>和<strong>注册读取</strong>权限的共享访问策略。</p>
    </blockquote>
  </li>
  <li>
    <p>将 <strong>“&lt;your event hub endpoint&gt;”</strong>、 <strong>“&lt;your event hub path&gt;”</strong> 和 <strong>“&lt;your event hub SaS key&gt;”</strong> 替换为你之前在本实验室中保存的值。</p>
  </li>
  <li>
    <p>找到注释 <code>// 在下方插入 Main 方法</code>。</p>
  </li>
  <li>
    <p>要实现 <strong>Main</strong> 方法，请输入以下代码：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">c#</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock18" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock18" class="mt-0"><code class="language-csharp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)
 </span></span>{
     ConsoleHelper.WriteColorMessage(<span class="hljs-string"><span class="hljs-string">"Cheese Cave Operator\n"</span></span>, ConsoleColor.Yellow);

     <span class="hljs-comment"><span class="hljs-comment">// 创建一个 EventHubClient 实例以连接到 IoT 中心与事件中心兼容的终结点。</span></span>
     <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> connectionString = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventHubsConnectionStringBuilder(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(eventHubsCompatibleEndpoint), eventHubsCompatiblePath, iotHubSasKeyName, iotHubSasKey);
     eventHubClient = EventHubClient.CreateFromConnectionString(connectionString.ToString());

     <span class="hljs-comment"><span class="hljs-comment">// 为中心上的每个分区创建一个 PartitionReceiver。</span></span>
     <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> runtimeInfo = eventHubClient.GetRuntimeInformationAsync().GetAwaiter().GetResult();
     <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> d2cPartitions = runtimeInfo.PartitionIds;

     <span class="hljs-comment"><span class="hljs-comment">// 在下方插入注册所需属性更改处理程序代码</span></span>

     <span class="hljs-comment"><span class="hljs-comment">// 在下方插入创建服务客户端实例</span></span>

     <span class="hljs-comment"><span class="hljs-comment">// 创建接收方以侦听消息。</span></span>
     <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tasks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Task&gt;();
     <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> partition <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> d2cPartitions)
     {
         asks.Add(ReceiveMessagesFromDeviceAsync(partition));
     }

     <span class="hljs-comment"><span class="hljs-comment">// 等待所有 PartitionReceivers 完成。</span></span>
     Task.WaitAll(tasks.ToArray());
 }
</code></pre>
  </li>
  <li>
    <p>花点时间检查你刚刚输入的代码（和代码注释）。</p>

    <p>请注意，此处使用了 <strong>EventHubsConnectionStringBuilder</strong> 类（这实际上是一个帮助程序类，可将多个值连接为正确的格式）来构造 <strong>EventHubClient</strong> 连接字符串。此类随后用于连接到事件中心终结点，并填充 <strong>eventHubClient</strong> 变量。</p>

    <p>然后，<strong>eventHubClient</strong> 用于检索事件中心的运行时信息。此信息中包含：</p>

    <ul>
      <li><strong>CreatedAt</strong> - 创建事件中心的日期/时间</li>
      <li><strong>PartitionCount</strong> - 分区数（大多数 IoT 中心配置有 4 个分区）</li>
      <li><strong>PartitionIds</strong> - 包含分区 ID 的字符串数组</li>
      <li><strong>Path</strong> - 事件中心实体路径</li>
    </ul>

    <p>分区 ID 数组存储在 <strong>d2cPartitions</strong> 变量中，该变量将在短期内用于创建将从每个分区接收消息的任务列表。</p>

    <blockquote>
      <p><strong>信息</strong>： 可在<a href="https://docs.microsoft.com/zh-cn/azure/iot-hub/iot-hub-scaling#partitions">此处</a>详细了解分区用途。</p>
    </blockquote>

    <p>由于从设备向 IoT 中心发送的消息可能由任意分区处理，因此应用必须从每个分区中检索消息。代码的下一部分创建异步任务列表 - 每个任务将接收来自特定分区的消息。最后一行将等待所有任务完成 - 由于每个任务将进去无限循环，此行可阻止应用程序退出。</p>
  </li>
  <li>
    <p>找到注释 <code>在下方插入 ReceiveMessagesFromDeviceAsync 方法</code>。</p>
  </li>
  <li>
    <p>要实现 <strong>ReceiveMessagesFromDeviceAsync</strong> 方法，请输入以下代码：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">c#</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock19" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock19" class="mt-0"><code class="language-csharp hljs"> <span class="hljs-comment"><span class="hljs-comment">// 异步为分区创建 PartitionReceiver，然后开始读取从模拟客户端发送的所有消息。</span></span>
 <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReceiveMessagesFromDeviceAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> partition</span></span></span><span class="hljs-function">)
 </span></span>{
     <span class="hljs-comment"><span class="hljs-comment">// 使用默认使用者组创建接收方。</span></span>
     <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> eventHubReceiver = eventHubClient.CreateReceiver(<span class="hljs-string"><span class="hljs-string">"$Default"</span></span>, partition, EventPosition.FromEnqueuedTime(DateTime.Now));
     Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Created receiver on partition: "</span></span> + partition);

     <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>)
     {
         <span class="hljs-comment"><span class="hljs-comment">// 检查 EventData - 如果没有要检索的内容，此方法将超时。</span></span>
         <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> events = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> eventHubReceiver.ReceiveAsync(<span class="hljs-number"><span class="hljs-number">100</span></span>);

         <span class="hljs-comment"><span class="hljs-comment">// 如果批处理中有数据，请对其进行处理。</span></span>
         <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (events == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>;

         <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (EventData eventData <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> events)
         {
             <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> data = Encoding.UTF8.GetString(eventData.Body.Array);

             ConsoleHelper.WriteGreenMessage(<span class="hljs-string"><span class="hljs-string">"Telemetry received: "</span></span> + data);

             <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> prop <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> eventData.Properties)
             {
                 <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prop.Value.ToString() == <span class="hljs-string"><span class="hljs-string">"true"</span></span>)
                 {
                     ConsoleHelper.WriteRedMessage(prop.Key);
                 }
             }
             Console.WriteLine();
         }
     }
 }
</code></pre>

    <p>如你所见，此方法包含用于定义目标分区的参数。回想一下，对于指定了 4 个分区的默认配置，调用 4 次此方法，每次调用异步并行运行，每个分区一个。</p>

    <p>此方法的第一部分创建事件中心接收方。该代码指定使用 <strong>$Default</strong> 使用者组（但常常创建自定义使用者组）、分区以及最终从事件分区的哪个位置开始接收数据。在本例中，接收方仅关注从当前时间开始排队的消息 - 还可使用其他选项提供数据流开头，数据流结尾或特定偏移量。</p>

    <blockquote>
      <p><strong>信息</strong>：可在<a href="https://docs.microsoft.com/zh-cn/azure/event-hubs/event-hubs-features#consumer-groups">此处</a>详细了解使用者组</p>
    </blockquote>

    <p>创建接收方后，应用即会进入无限循环，并等待接收事件。</p>

    <blockquote>
      <p><strong>备注：</strong> <code>eventHubReceiver.ReceiveAsync(100)</code> 代码指定可一次性接收的最大事件数，但它并不会等待接收该数量的事件，而是在有至少一个可用事件后立即返回。如果未返回任何事件（因为超时），则将继续循环，并且代码会等待更多事件。</p>
    </blockquote>

    <p>如果接收到一个或多个事件，则每个事件数据主体将从字节数组转换为字符串，并写入控制台。然后循环访问事件数据属性，并且在本例中，应检查事件数据属性以查看值是否为 true - 在当前场景中，这表示警报。如果发现警报，则将其写入控制台。</p>
  </li>
  <li>
    <p>在 <strong>“文件”</strong> 菜单，将你的更改保存到 Program.cs 文件，单击 <strong>“保存”</strong>。</p>
  </li>
</ol>

<h4 id="任务-3测试你的代码以接收遥测">任务 3：测试你的代码以接收遥测</h4>

<p>此测试很重要，请检查后端应用是否正在接收模拟设备发送的遥测数据。请记住，设备应用仍在运行，且仍在发送遥测数据。</p>

<ol>
  <li>
    <p>要在终端中运行 <strong>“CheeseCaveOperator”</strong> 后端应用，请打开“终端”窗格，然后输入以下命令：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">code</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock20" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock20" class="mt-0"><code class="language-bash hljs"> dotnet run
</code></pre>

    <p>此命令将在当前文件夹中运行 <strong>“Program.cs”</strong> 文件。</p>

    <blockquote>
      <p><strong>备注：</strong>  你可以忽略有关未使用的变量 <strong>“serviceConnectionString”</strong> 的警告 - 我们很快就将添加代码来使用该变量。</p>
    </blockquote>
  </li>
  <li>
    <p>花一分钟时间观察到终端的输出。</p>

    <p>你应该快速看到控制台输出，如果该应用成功连接到 IoT 中心，该应用将几乎立即显示遥测消息数据。</p>

    <p>如果没有，请仔细检查你的 IoT 中心服务连接字符串，注意该字符串应该是服务连接字符串，而不是任何其他字符串：</p>

    <p><a href="media/LAB_AK_15-cheesecave-telemetry-received.png" target="_blank"><img src="media/LAB_AK_15-cheesecave-telemetry-received.png" alt="控制台输出"></a></p>

    <blockquote>
      <p><strong>备注：</strong>  绿色文本表示一切正常，红色文本表示存在异常。如果屏幕上未出现类似图像，请首先检查设备连接字符串。</p>
    </blockquote>
  </li>
  <li>
    <p>让此应用运行更长的时间。</p>
  </li>
  <li>
    <p>在操作员应用和设备应用都运行的情况下，验证前者显示的遥测与后者发送的遥测同步。</p>

    <p>直观地比较正在发送的遥测与正在接收的遥测。</p>

    <ul>
      <li>是否有确切的数据匹配？</li>
      <li>从发送数据到接收数据之间是否有很大的延迟？</li>
    </ul>
  </li>
  <li>
    <p>在验证遥测数据后，停止运行应用并关闭两个 VS Code 实例中的“终端”窗格，但不关闭 Visual Studio Code 窗口。</p>
  </li>
</ol>

<p>你现在有一个应用从设备发送遥测数据，还有一个后端应用确认收到数据。在下一个练习中，你将开始执行处理控制端的步骤 - 数据出现问题时该怎么办。</p>

<h3 id="练习-4编写代码以调用直接方法">练习 4：编写代码以调用直接方法</h3>

<p>用于从后端应用调用直接方法的调用可以在有效负载中包含多个参数。直接方法通常用于打开和关闭设备功能或指定设备的设置。</p>

<p>在 Contoso 场景中，你将在设备上实现一种直接方法来控制奶酪储藏室中风扇的运行（通过打开或关闭风扇模拟控制温度和湿度）。操作员应用程序将与 IoT 中心通信，以调用设备上的直接方法。</p>

<p>当奶酪储藏室设备收到运行直接方法的指令时，需要检查一些错误条件。其中一项检查是在风扇处于故障状态时响应错误。需要进行报告的另一个错误条件是接收到无效参数。考虑到设备的潜在远程性，清晰的错误报告非常重要。</p>

<p>直接方法要求后端应用准备参数，然后进行调用，以指定在其上调用方法的单个设备。然后，后端应用将等待并报告响应。</p>

<p>设备应用包含直接方法的函数代码。函数名称已注册到设备的 IoT 客户端。此过程可确保客户端知道当调用来自 IoT 中心时所要运行的函数（可能涉及许多直接方法）。</p>

<p>在本练习中，将通过添加直接方法的代码来更新设备应用，该方法将模拟在奶酪储藏室中打开风扇。接下来，将代码添加到后端服务应用以调用此直接方法。</p>

<h4 id="任务-1添加代码以在设备应用中定义直接方法">任务 1：添加代码以在设备应用中定义直接方法</h4>

<ol>
  <li>
    <p>返回到包含 <strong>cheesecavedevice</strong> 应用程序的 Visual Studio Code 实例。</p>

    <blockquote>
      <p><strong>备注：</strong> 如果应用仍在运行，请使用“终端”窗格退出应用（在“终端”窗格内单击以设置焦点，然后按 <strong>CTRL+C</strong> 退出正在运行的应用程序）。</p>
    </blockquote>
  </li>
  <li>
    <p>确保 <strong>Program.cs</strong>  在代码编辑器中打开。</p>
  </li>
  <li>
    <p>找到注释 <code>在下方插入注册直接方法代码</code>。</p>
  </li>
  <li>
    <p>要注册直接方法，请输入以下代码：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">c#</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock21" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock21" class="mt-0"><code class="language-csharp hljs"> <span class="hljs-comment"><span class="hljs-comment">// 为直接方法调用创建处理程序</span></span>
 deviceClient.SetMethodHandlerAsync(<span class="hljs-string"><span class="hljs-string">"SetFanState"</span></span>, SetFanState, <span class="hljs-literal"><span class="hljs-literal">null</span></span>).Wait();
</code></pre>

    <p>请注意，<strong>SetFanState</strong> 直接方法处理程序也由此代码设置。正如你所见，deviceClient 的 <strong>SetMethodHandlerAsync</strong> 方法将远程方法名称 <code>"SetFanState"</code>，以及要调用的实际本地方法和用户上下文对象（在本例中为 null）作为参数。</p>
  </li>
  <li>
    <p>找到注释 <code>在下方插入 SetFanState 方法</code>。</p>
  </li>
  <li>
    <p>要实现 <strong>SetFanState</strong> 直接方法，请输入以下代码：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">c#</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock22" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock22" class="mt-0"><code class="language-csharp hljs"> <span class="hljs-comment"><span class="hljs-comment">// 处理直接方法调用</span></span>
 <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Task&lt;MethodResponse&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetFanState</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MethodRequest methodRequest, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userContext</span></span></span><span class="hljs-function">)
 </span></span>{
     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cheeseCave.FanState == StateEnum.Failed)
     {
         <span class="hljs-comment"><span class="hljs-comment">// 通过 400 错误消息确认直接方法调用结果。</span></span>
         <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> result = <span class="hljs-string"><span class="hljs-string">"{\"result\":\"Fan failed\"}"</span></span>;
         ConsoleHelper.WriteRedMessage(<span class="hljs-string"><span class="hljs-string">"Direct method failed: "</span></span> + result);
         <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.FromResult(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MethodResponse(Encoding.UTF8.GetBytes(result), <span class="hljs-number"><span class="hljs-number">400</span></span>));
     }
     <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>
     {
         <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>
         {
             <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = Encoding.UTF8.GetString(methodRequest.Data);

             <span class="hljs-comment"><span class="hljs-comment">// 从数据中删除引号。</span></span>
             data = data.Replace(<span class="hljs-string"><span class="hljs-string">"\""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>);

             <span class="hljs-comment"><span class="hljs-comment">// Parse the payload, and trigger an exception if it's not valid.</span></span>
             cheeseCave.UpdateFan((StateEnum)Enum.Parse(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(StateEnum), data));
             ConsoleHelper.WriteGreenMessage(<span class="hljs-string"><span class="hljs-string">"Fan set to: "</span></span> + data);

             <span class="hljs-comment"><span class="hljs-comment">// 通过 200 成功消息确认直接方法调用结果。</span></span>
             <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> result = <span class="hljs-string"><span class="hljs-string">"{\"result\":\"Executed direct method: "</span></span> + methodRequest.Name + <span class="hljs-string"><span class="hljs-string">"\"}"</span></span>;
             <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.FromResult(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MethodResponse(Encoding.UTF8.GetBytes(result), <span class="hljs-number"><span class="hljs-number">200</span></span>));
         }
         <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>
         {
             <span class="hljs-comment"><span class="hljs-comment">// 通过 400 错误消息确认直接方法调用结果。</span></span>
             <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> result = <span class="hljs-string"><span class="hljs-string">"{\"result\":\"Invalid parameter\"}"</span></span>;
             ConsoleHelper.WriteRedMessage(<span class="hljs-string"><span class="hljs-string">"Direct method failed: "</span></span> + result);
             <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.FromResult(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MethodResponse(Encoding.UTF8.GetBytes(result), <span class="hljs-number"><span class="hljs-number">400</span></span>));
         }
     }
 }
</code></pre>

    <p>这是在通过 IoT 中心调用关联的远程方法（也称为 <strong>SetFanState</strong>）时，设备上运行的方法。请注意，除了接收 <strong>MethodRequest</strong> 实例之外，它还接收在注册直接消息回叫时定义的 <strong>userContext</strong> 对象（在本例中为 null）。</p>

    <p>此方法的第一行确定奶酪储藏室风扇当前是否处于 <strong>“故障”</strong> 状态 - 奶酪储藏室模拟器制定的假设是，一旦风扇处于故障状态，任何后续命令都将自动失败。因此，将创建一个 <strong>“result”</strong> 属性设置为 <strong>“Fan Failed”</strong> 的 JSON 字符串。然后会构造一个新的 <strong>MethodResponse</strong> 对象，该对象的结果字符串编码为一个字节数组和一个 HTTP 状态代码 - 本例中使用 <strong>400</strong>，在 REST API 的上下文中表示发生一般性客户端错误。由于需要直接方法回叫才可返回 <strong>Task&lt;MethodResponse&gt;</strong>，因此将创建和返回新任务。</p>

    <blockquote>
      <p><strong>信息</strong>： 可在<a href="https://restfulapi.net/http-status-codes/">此处</a>详细了解如何在 REST API 中使用 HTTP 状态代码。</p>
    </blockquote>

    <p>如果风扇状态并非 <strong>“故障”</strong>，则代码将继续处理在方法请求中发送的数据。 <strong>“methodRequest.Data”</strong> 属性中包含字节数组形式的数据，因此它首先转换为字符串。在此场景中，该数据应为以下两个值（包括引号）：</p>

    <ul>
      <li>“On”</li>
      <li>“Off”</li>
    </ul>

    <p>假定接收的数据映射到 <strong>StateEnum</strong> 的成员：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">c#</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock23" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock23" class="mt-0"><code class="language-csharp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> StateEnum
 {
     Off,
     On,
     Failed
 }
</code></pre>

    <p>为了分析数据，必须先去除引号，然后使用 <strong>Enum.Parse</strong> 方法来查找匹配的枚举值。如果此操作失败（数据需要完全匹配），则会引发异常，下面捕获了该异常。请注意，异常处理程序创建并返回的错误方法响应与为风扇故障状态创建的响应类似。</p>

    <p>如果在 <strong>StateEnum</strong> 中发现了匹配的值，则会调用奶酪储藏室模拟器 <strong>UpdateFan</strong> 方法。在本例中，该方法仅仅将 <strong>“FanState”</strong> 属性设置为提供的值 - 实际实现将与风扇交互，以更改状态并确定状态更改是否成功。但在本场景中，假定状态更改成功，并创建和返回相应的 <strong>result</strong> 和 <strong>MethodResponse</strong> - 此次使用 HTTP 状态代码 <strong>200</strong> 来指示操作成功。</p>
  </li>
  <li>
    <p>在 <strong>“文件”</strong> 菜单中，单击 <strong>“保存”</strong>，保存 Program.cs 文件。</p>
  </li>
</ol>

<p>现在即已经完成了设备端所需的编码。接下来，需要将代码添加到将调用直接方法的后端操作员应用程序。</p>

<h4 id="任务-2添加代码以调用直接方法">任务 2：添加代码以调用直接方法</h4>

<ol>
  <li>
    <p>返回到包含 <strong>CheeseCaveOperator</strong> 应用程序的 Visual Studio Code 实例。</p>

    <blockquote>
      <p><strong>备注：</strong> 如果应用仍在运行，请使用“终端”窗格退出应用（在“终端”窗格内单击以设置焦点，然后按 <strong>CTRL+C</strong> 退出正在运行的应用程序）。</p>
    </blockquote>
  </li>
  <li>
    <p>确保 <strong>Program.cs</strong> 在代码编辑器中打开。</p>
  </li>
  <li>
    <p>找到注释 <code>在下方插入服务客户端变量</code>。</p>
  </li>
  <li>
    <p>要添加用于保存服务客户端实例的全局变量，请输入以下代码：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">c#</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock24" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock24" class="mt-0"><code class="language-csharp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ServiceClient serviceClient;
</code></pre>
  </li>
  <li>
    <p>找到注释 <code>在下方插入创建服务客户端实例</code>。</p>
  </li>
  <li>
    <p>要添加创建服务客户端实例并调用直接方法的代码，请输入以下代码：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">c#</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock25" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock25" class="mt-0"><code class="language-csharp hljs"> <span class="hljs-comment"><span class="hljs-comment">// 创建 ServiceClient 与中心上面向服务的终结点进行通信。</span></span>
 serviceClient = ServiceClient.CreateFromConnectionString(serviceConnectionString);
 InvokeMethod().GetAwaiter().GetResult();
</code></pre>
  </li>
  <li>
    <p>找到注释 <code>在下方插入 InvokeMethod 方法</code>。</p>
  </li>
  <li>
    <p>要添加调用直接方法的代码，请输入以下代码：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">c#</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock26" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock26" class="mt-0"><code class="language-csharp hljs"> <span class="hljs-comment"><span class="hljs-comment">// 处理调用直接方法。</span></span>
 <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InvokeMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)
 </span></span>{
     <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>
     {
         <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> methodInvocation = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CloudToDeviceMethod(<span class="hljs-string"><span class="hljs-string">"SetFanState"</span></span>) { ResponseTimeout = TimeSpan.FromSeconds(<span class="hljs-number"><span class="hljs-number">30</span></span>) };
         <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> payload = JsonConvert.SerializeObject(<span class="hljs-string"><span class="hljs-string">"On"</span></span>);

         methodInvocation.SetPayloadJson(payload);

         <span class="hljs-comment"><span class="hljs-comment">// 异步调用直接方法，并从模拟设备获取响应。</span></span>
         <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> serviceClient.InvokeDeviceMethodAsync(deviceId, methodInvocation);

         <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.Status == <span class="hljs-number"><span class="hljs-number">200</span></span>)
         {
             ConsoleHelper.WriteGreenMessage(<span class="hljs-string"><span class="hljs-string">"Direct method invoked: "</span></span> + response.GetPayloadAsJson());
         }
         <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>
         {
             ConsoleHelper.WriteRedMessage(<span class="hljs-string"><span class="hljs-string">"Direct method failed: "</span></span> + response.GetPayloadAsJson());
         }
     }
     <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>
     {
         ConsoleHelper.WriteRedMessage(<span class="hljs-string"><span class="hljs-string">"Direct method failed: timed-out"</span></span>);
     }
 }
</code></pre>

    <p>此代码用于调用设备应用上的 <strong>SetFanState</strong> 直接方法。</p>
  </li>
  <li>
    <p>在 <strong>“文件”</strong> 菜单中，单击 <strong>“保存”</strong>，保存 Program.cs 文件。</p>
  </li>
</ol>

<p>现在已经完成了代码更改，以支持 <strong>SetFanState</strong> 直接方法。</p>

<h4 id="任务-3测试直接方法">任务 3：测试直接方法</h4>

<p>若要测试直接方法，需要以正确的顺序启动应用。你不能调用尚未注册的直接方法！</p>

<ol>
  <li>
    <p>切换到包含 <strong>cheesecavedevice</strong> 设备应用的 Visual Studio Code 实例。</p>
  </li>
  <li>
    <p>要启动 <strong>cheesecavedevice</strong> 设备应用，请打开“终端”窗格，然后输入 <code>dotnet run</code> 命令。</p>

    <p>它将开始写入终端，并且将显示遥测消息。</p>
  </li>
  <li>
    <p>切换到包含 <strong>CheeseCaveOperator</strong> 后端应用的 Visual Studio Code 实例。</p>
  </li>
  <li>
    <p>要启动 <strong>CheeseCaveOperator</strong> 后端应用，请打开“终端”窗格，然后输入 <code>dotnet run</code> 命令。</p>

    <blockquote>
      <p><strong>备注：</strong>  如果看到 <code>Direct method failed: timed-out</code> 消息，请仔细检查是否已将更改保存在 <strong>CheeseCaveDevice</strong> 中并启动了该应用。</p>
    </blockquote>

    <p>CheeseCaveOperator 后端应用将立即调用直接方法。</p>

    <p>请注意，输出如下所示：</p>

    <p><a href="media/LAB_AK_15-cheesecave-direct-method-sent.png" target="_blank"><img src="media/LAB_AK_15-cheesecave-direct-method-sent.png" alt="控制台输出"></a></p>
  </li>
  <li>
    <p>现在检查 <strong>cheesecavedevice</strong> 设备应用的控制台输出，你会看到风扇已打开。</p>

    <p><a href="media/LAB_AK_15-cheesecave-direct-method-received.png" target="_blank"><img src="media/LAB_AK_15-cheesecave-direct-method-received.png" alt="控制台输出"></a></p>
  </li>
</ol>

<p>现在，你已成功监视和控制远程设备。已在设备上实现了可从云中调用的直接方法。在 Contoso 场景中，直接方法用于打开风扇，这将使储藏室中的环境达到我们所需的设置。你应注意到，温度和湿度读数会随着时间的推移而降低，最终会消除警报（除非风扇故障）。</p>

<p>但如果你希望远程指定奶酪储藏室环境的所需设置，该怎么办？也许你想在老化过程中的某个时刻为奶酪储藏室设置特定的目标温度。可以使用直接方法（这是一种有效方法）指定所需的设置，也可以使用 IoT 中心专为此目的设计的另一个功能：设备孪生。在下一个练习中，你将在解决方案中实现设备孪生属性。</p>

<h3 id="练习-5实现设备孪生功能">练习 5：实现设备孪生功能</h3>

<p>提醒一下，一对设备孪生包含四种类型的信息：</p>

<ul>
  <li><strong>标签</strong>： 设备上不可见的设备信息。</li>
  <li><strong>所需属性</strong>： 后端应用指定的所需设置。</li>
  <li><strong>报告的属性</strong>： 设备上报告的设置值。</li>
  <li><strong>设备标识属性</strong>： 标识设备的只读信息。</li>
</ul>

<p>通过 IoT 中心管理的设备孪生专为查询而设计，并且它们与真实的 IoT 设备同步。可随时通过后端应用查询设备孪生。该查询可以返回设备的当前状态信息。获取此数据不涉及对设备的调用，因为设备和孪生将同步。设备孪生的许多功能由 Azure IoT 中心提供，因此无需编写太多代码即可使用它们。</p>

<p>孪生设备的功能和直接方法之间存在一些重叠。可以使用直接方法设置设备属性，这似乎是一种直观的处理方式。但是，如果需要访问设置，使用直接方法就会要求后端应用对这些设置进行显式记录。如果使用设备孪生，默认情况下会存储和维护此信息。</p>

<p>在本练习中，将向设备应用和后端服务应用添加一些代码，以显示运行中的设备孪生同步。</p>

<h4 id="任务-1添加代码以使用设备孪生同步设备属性">任务 1：添加代码以使用设备孪生同步设备属性</h4>

<ol>
  <li>
    <p>返回到正在运行 <strong>CheeseCaveOperator</strong> 后端应用的 Visual Studio Code 实例。</p>
  </li>
  <li>
    <p>如果应用仍在运行，请将输入焦点放在终端上，然后按 <strong>Ctrl+C</strong> 退出应用。</p>
  </li>
  <li>
    <p>确保 <strong>Program.cs</strong> 打开。</p>
  </li>
  <li>
    <p>找到注释 <code>在下方插入注册表管理器变量</code>。</p>
  </li>
  <li>
    <p>要插入注册表管理器便利，请输入以下代码：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">c#</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock27" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock27" class="mt-0"><code class="language-csharp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> RegistryManager registryManager;
</code></pre>
  </li>
  <li>
    <p>找到注释 <code>在下方插入注册所需属性更改处理程序代码</code>。</p>
  </li>
  <li>
    <p>要添加创建注册表管理器实例并设置孪生属性的功能，请输入以下代码：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">c#</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock28" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock28" class="mt-0"><code class="language-csharp hljs"> <span class="hljs-comment"><span class="hljs-comment">// 注册表管理器用于访问数字孪生。</span></span>
 registryManager = RegistryManager.CreateFromConnectionString(serviceConnectionString);
 SetTwinProperties().Wait();
</code></pre>
  </li>
  <li>
    <p>找到注释 <code>在下方插入设备孪生部分</code>。</p>
  </li>
  <li>
    <p>要添加更新设备孪生所需属性的功能，请输入以下代码：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">c#</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock29" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock29" class="mt-0"><code class="language-csharp hljs"> <span class="hljs-comment"><span class="hljs-comment">// 设备孪生部分。</span></span>

 <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTwinProperties</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)
 </span></span>{
     <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> twin = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> registryManager.GetTwinAsync(deviceId);
     <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> patch =
         <span class="hljs-string"><span class="hljs-string">@"{
             tags: {
                 customerID: 'Customer1',
                 cheeseCave: 'CheeseCave1'
             },
             properties: {
                 desired: {
                     patchId: 'set values',
                     temperature: '50',
                     humidity: '85'
                 }
             }
         }"</span></span>;
     <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> registryManager.UpdateTwinAsync(twin.DeviceId, patch, twin.ETag);

     <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> query = registryManager.CreateQuery(
         <span class="hljs-string"><span class="hljs-string">"SELECT * FROM devices WHERE tags.cheeseCave = 'CheeseCave1'"</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>);
     <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> twinsInCheeseCave1 = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> query.GetNextAsTwinAsync();
     Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Devices in CheeseCave1: {0}"</span></span>,
         <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Join(<span class="hljs-string"><span class="hljs-string">", "</span></span>, twinsInCheeseCave1.Select(t =&gt; t.DeviceId)));
 }
</code></pre>

    <blockquote>
      <p><strong>备注：</strong>  <strong>SetTwinProperties</strong> 方法创建一段 JSON，用于定义将添加到设备孪生的标记和属性，然后更新孪生。该方法的下一部分演示如何执行查询以列出 <strong>cheeseCave</strong> 标记设置为 <strong>“CheeseCave1”</strong> 的设备。此查询要求连接具有 <strong>“注册表读取”</strong> 权限。</p>
    </blockquote>
  </li>
  <li>
    <p>在 <strong>“文件”</strong> 菜单中，单击 <strong>“保存”</strong>，保存 Program.cs 文件。</p>
  </li>
</ol>

<h4 id="任务-2添加代码以同步设备的设备孪生设置">任务 2：添加代码以同步设备的设备孪生设置</h4>

<ol>
  <li>
    <p>返回到包含 <strong>cheesecavedevice</strong> 应用的 Visual Studio Code 实例。</p>
  </li>
  <li>
    <p>如果应用仍在运行，请将输入焦点放在终端上，然后按 <strong>Ctrl+C</strong> 退出应用。</p>
  </li>
  <li>
    <p>确保 <strong>Program.cs</strong> 文件在“代码编辑器”窗格中打开。</p>
  </li>
  <li>
    <p>找到注释 <code>在下方插入注册所需属性更改处理程序代码</code>。</p>
  </li>
  <li>
    <p>要注册所需属性更改处理程序，请添加以下代码：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">c#</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock30" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock30" class="mt-0"><code class="language-csharp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Get the device twin to report the initial desired properties.</span></span>
 Twin deviceTwin = deviceClient.GetTwinAsync().GetAwaiter().GetResult();
 ConsoleHelper.WriteGreenMessage(<span class="hljs-string"><span class="hljs-string">"Initial twin desired properties: "</span></span> + deviceTwin.Properties.Desired.ToJson());

 <span class="hljs-comment"><span class="hljs-comment">// Set the device twin update callback.</span></span>
 deviceClient.SetDesiredPropertyUpdateCallbackAsync(OnDesiredPropertyChanged, <span class="hljs-literal"><span class="hljs-literal">null</span></span>).Wait();
</code></pre>
  </li>
  <li>
    <p>找到注释 <code>在下方插入 OnDesiredPropertyChanged 方法</code>。</p>
  </li>
  <li>
    <p>要添加响应设备孪生属性更改的功能，请输入以下代码：</p>

    <div class="code-header mt-3 mb-0 bg-light d-flex justify-content-between border"><span class="mx-2 text-muted text-capitalize font-weight-light">c#</span><button class="m-0 btn btn-code btn-sm btn-light codeBtn rounded-0 border-left text-muted font-weight-light" data-clipboard-target="#codeBlock31" type="button"><i class="fa fa-files-o mr-2" aria-hidden="true"></i>Copy</button></div><pre id="codeBlock31" class="mt-0"><code class="language-csharp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDesiredPropertyChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TwinCollection desiredProperties, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userContext</span></span></span><span class="hljs-function">)
 </span></span>{
     <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>
     {
         <span class="hljs-comment"><span class="hljs-comment">// 更改奶酪储藏室模拟器属性</span></span>
         cheeseCave.DesiredHumidity = desiredProperties[<span class="hljs-string"><span class="hljs-string">"humidity"</span></span>];
         cheeseCave.DesiredTemperature = desiredProperties[<span class="hljs-string"><span class="hljs-string">"temperature"</span></span>];
         ConsoleHelper.WriteGreenMessage(<span class="hljs-string"><span class="hljs-string">"Setting desired humidity to "</span></span> + desiredProperties[<span class="hljs-string"><span class="hljs-string">"humidity"</span></span>]);
         ConsoleHelper.WriteGreenMessage(<span class="hljs-string"><span class="hljs-string">"Setting desired temperature to "</span></span> + desiredProperties[<span class="hljs-string"><span class="hljs-string">"temperature"</span></span>]);

         <span class="hljs-comment"><span class="hljs-comment">// 将属性报告回 IoT 中心。</span></span>
         <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> reportedProperties = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TwinCollection();
         reportedProperties[<span class="hljs-string"><span class="hljs-string">"fanstate"</span></span>] = cheeseCave.FanState.ToString();
         reportedProperties[<span class="hljs-string"><span class="hljs-string">"humidity"</span></span>] = cheeseCave.DesiredHumidity;
         reportedProperties[<span class="hljs-string"><span class="hljs-string">"temperature"</span></span>] = cheeseCave.DesiredTemperature;
         <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> deviceClient.UpdateReportedPropertiesAsync(reportedProperties);

         ConsoleHelper.WriteGreenMessage(<span class="hljs-string"><span class="hljs-string">"\nTwin state reported: "</span></span> + reportedProperties.ToJson());
     }
     <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>
     {
         ConsoleHelper.WriteRedMessage(<span class="hljs-string"><span class="hljs-string">"Failed to update device twin"</span></span>);
     }
 }
</code></pre>

    <p>此代码定义在设备孪生中所需属性更改时调用的处理程序。请注意，然后将新值报告回 IoT 中心以确认更改。</p>
  </li>
  <li>
    <p>在 <strong>“文件”</strong> 菜单中，单击 <strong>“保存”</strong>，保存 Program.cs 文件。</p>

    <blockquote>
      <p><strong>备注：</strong> 现在，你已经在应用中添加了对设备孪生的支持，可以重新考虑使用显式变量，例如 <strong>desiredHumidity</strong>。你可以改用设备孪生对象中的变量。</p>
    </blockquote>
  </li>
</ol>

<h4 id="任务-3测试设备孪生">任务 3：测试设备孪生</h4>

<p>要测试管理设备孪生所需属性更改的代码，请按正确的顺序启动应用，先启动设备应用程序，然后启动后端应用程序。</p>

<ol>
  <li>
    <p>切换到包含 <strong>cheesecavedevice</strong> 设备应用的 Visual Studio Code 实例。</p>
  </li>
  <li>
    <p>要启动 <strong>cheesecavedevice</strong> 设备应用，请打开“终端”窗格，然后输入 <code>dotnet run</code> 命令。</p>

    <p>它将开始写入终端，并且将显示遥测消息。</p>
  </li>
  <li>
    <p>切换到包含 <strong>CheeseCaveOperator</strong> 后端应用的 Visual Studio Code 实例。</p>
  </li>
  <li>
    <p>要启动 <strong>CheeseCaveOperator</strong> 后端应用，请打开“终端”窗格，然后输入 <code>dotnet run</code> 命令。</p>
  </li>
  <li>
    <p>切换回包含 <strong>cheesecavedevice</strong> 设备应用的 Visual Studio Code 实例。</p>
  </li>
  <li>
    <p>检查控制台输出，并确认设备孪生已正确同步。</p>

    <p><a href="media/LAB_AK_15-cheesecave-device-twin-received.png" target="_blank"><img src="media/LAB_AK_15-cheesecave-device-twin-received.png" alt="控制台输出"></a></p>

    <p>如果让风扇工作，则最终可看到红色警报关闭（除非风扇故障）</p>

    <p><a href="media/LAB_AK_15-cheesecave-device-twin-success.png" target="_blank"><img src="media/LAB_AK_15-cheesecave-device-twin-success.png" alt="控制台输出"></a></p>
  </li>
  <li>
    <p>对于这两个 Visual Studio Code 实例，请停止应用，然后关闭“Visual Studio Code”窗口。</p>
  </li>
</ol>

<p>在本实验室中实现的代码并未达到生产质量要求，但确实演示了使用直接方法和设备孪生属性的组合来监视和控制 IoT 设备的基础知识。你应该认识到，在此实现中，仅在首次运行后端服务应用时才发送操作员控制消息。通常，后端服务应用需要浏览器界面，以便操作员在需要时发送直接方法或设置设备孪生属性。</p>

            </article>
        </main>
    </div>
    <footer class="fixed-bottom d-print-none">
        <nav class="navbar navbar-light bg-light d-flex justify-content-around">
            <span class="navbar-text">
                <i class="fa fa-github" aria-hidden="true"></i>
                <a href="https://github.com/MicrosoftLearning/AZ-220ZH-Microsoft-Azure-IoT-Developer" target="_blank" class="ml-2">
                    MicrosoftLearning/AZ-220ZH-Microsoft-Azure-IoT-Developer
                </a>
            </span>
        </nav>
    </footer>
    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script src="../../assets/js/script_v%3D653337691cd169b6aa5719d4ea66f4e6a878a19c.js"></script>



</body></html>